use core::panic;

use clap::{Parser, Subcommand};
use contract::Token;
use contract_amm::AmmAction;
use contract_amm::AmmState;

use hyle::model::BlobTransaction;
use hyle::model::ProofTransaction;
use hyle::model::RegisterContractTransaction;
use sdk::{
    identity_provider::IdentityAction, BlobIndex, ContractAction, ContractInput, ContractName,
    Digestable,
};

// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods_amm::{GUEST_ELF, GUEST_ID};

#[derive(Parser)]
#[command(author, version, about, long_about = None)]
#[command(propagate_version = true)]
struct Cli {
    #[command(subcommand)]
    command: Commands,

    #[clap(long, short)]
    reproducible: bool,

    #[arg(long, default_value = "http://localhost:4321")]
    pub host: String,

    #[arg(long, default_value = "simple_amm")]
    pub contract_name: String,
}

#[derive(Subcommand)]
enum Commands {
    Register {},
    NewPair {
        token1: String,
        token2: String,
        amount1: u128,
        amount2: u128,
    },
    // VerifySwap {},
}

#[tokio::main]
async fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let cli = Cli::parse();

    let client = hyle::tools::rest_api_client::NodeApiHttpClient::new(cli.host);

    let contract_name = &cli.contract_name;

    match cli.command {
        Commands::Register {} => {
            // Build initial state of contract
            let initial_state = AmmState::default();
            println!("Initial state: {:?}", initial_state);

            // Send the transaction to register the contract
            let register_tx = RegisterContractTransaction {
                owner: "examples".to_string(),
                verifier: "risc0".into(),
                program_id: sdk::ProgramId(sdk::to_u8_array(&GUEST_ID).to_vec()),
                state_digest: initial_state.as_digest(),
                contract_name: contract_name.clone().into(),
            };
            let res = client
                .send_tx_register_contract(&register_tx)
                .await
                .unwrap()
                .text()
                .await
                .unwrap();

            println!("✅ Register contract tx sent. Tx hash: {}", res);
        }
        Commands::NewPair {
            token1,
            token2,
            amount1,
            amount2,
        } => {
            // Build initial state of contract
            let initial_state: AmmState = client
                .get_contract(&contract_name.clone().into())
                .await
                .unwrap()
                .state
                .into();

            let identity_cf: IdentityAction = IdentityAction::VerifyIdentity {
                account: "examples.hydentity".into(),
                nonce: 1,
            };

            let blobs = vec![
                identity_cf.as_blob(ContractName("hydentity".to_owned())),
                // // Declare pair on the amm contract
                AmmAction::NewPair {
                    pair: (token1.clone(), token2.clone()),
                    amounts: (amount1.clone(), amount2.clone()),
                }
                .as_blob(
                    ContractName(contract_name.clone()),
                    None,
                    Some(vec![BlobIndex(2), BlobIndex(3)]),
                ),
                // Init pair 0 amount
                sdk::erc20::ERC20Action::TransferFrom {
                    sender: "examples.hydentity".into(),
                    recipient: contract_name.clone(),
                    amount: amount1,
                }
                .as_blob(token1.clone().into(), Some(BlobIndex(1)), None),
                // Init pair 1 amount
                sdk::erc20::ERC20Action::TransferFrom {
                    sender: "examples.hydentity".into(),
                    recipient: contract_name.clone(),
                    amount: amount2,
                }
                .as_blob(token2.clone().into(), Some(BlobIndex(1)), None),
            ];
            let blob_tx = BlobTransaction {
                identity: "examples.hydentity".into(),
                blobs: blobs.clone(),
            };

            // Send the blob transaction
            let blob_tx_hash = client.send_tx_blob(&blob_tx).await.unwrap();
            println!("✅ Blob tx sent. Tx hash: {}", blob_tx_hash);

            // prove tx

            // Build the contract input
            let inputs = ContractInput {
                initial_state: initial_state.as_digest(),
                identity: "examples.hydentity".into(),
                tx_hash: "".into(),
                private_blob: sdk::BlobData(vec![]),
                blobs: blobs.clone(),
                index: sdk::BlobIndex(1),
            };

            // Generate the zk proof
            //
            let binary = if cli.reproducible {
                println!("Running with reproducible ELF binary.");
                std::fs::read("target/riscv-guest/riscv32im-risc0-zkvm-elf/docker/method/method")
                      .expect("Could not read ELF binary at target/riscv-guest/riscv32im-risc0-zkvm-elf/docker/method/method")
            } else {
                println!("Running non-reproducibly");
                GUEST_ELF.to_vec()
            };
            let (proof, _) = client_sdk::helpers::prove(&binary, &inputs).await.unwrap();

            let proof_tx = ProofTransaction {
                tx_hashes: vec![blob_tx_hash.clone()],
                proof,
                contract_name: contract_name.clone().into(),
            };

            // Send the proof transaction
            let proof_tx_hash = client
                .send_tx_proof(&proof_tx)
                .await
                .unwrap()
                .text()
                .await
                .unwrap();
            println!("✅ Proof tx sent. Tx hash: {}", proof_tx_hash);

            ///
            // Build the transfer a input
            ///
            let initial_state_a: Token = client
                .get_contract(&token1.clone().into())
                .await
                .unwrap()
                .state
                .into();

            let inputs = ContractInput {
                initial_state: initial_state_a.as_digest(),
                identity: "examples.hydentity".into(),
                tx_hash: "".into(),
                private_blob: sdk::BlobData(vec![]),
                blobs: blobs.clone(),
                index: sdk::BlobIndex(2),
            };

            // Generate the zk proof
            //
            let binary = if cli.reproducible {
                println!("Running with reproducible ELF binary.");
                std::fs::read("../../simple-token/host/target/riscv-guest/riscv32im-risc0-zkvm-elf/docker/method/method")
                      .expect("Could not read ELF binary at target/riscv-guest/riscv32im-risc0-zkvm-elf/docker/method/method")
            } else {
                println!("Running non-reproducibly");
                methods::GUEST_ELF.to_vec()
            };
            let (proof, _) = client_sdk::helpers::prove(&binary, &inputs).await.unwrap();

            let proof_tx = ProofTransaction {
                tx_hashes: vec![blob_tx_hash.clone()],
                proof,
                contract_name: token1.clone().into(),
            };

            // Send the proof transaction
            let proof_tx_hash = client
                .send_tx_proof(&proof_tx)
                .await
                .unwrap()
                .text()
                .await
                .unwrap();
            println!("✅ Proof tx sent. Tx hash: {}", proof_tx_hash);

            ///
            // Build the transfer b input
            ///
            let initial_state_b: Token = client
                .get_contract(&token2.clone().into())
                .await
                .unwrap()
                .state
                .into();

            let inputs = ContractInput {
                initial_state: initial_state_b.as_digest(),
                identity: "examples.hydentity".into(),
                tx_hash: "".into(),
                private_blob: sdk::BlobData(vec![]),
                blobs: blobs.clone(),
                index: sdk::BlobIndex(3),
            };

            // Generate the zk proof
            //
            let binary = if cli.reproducible {
                println!("Running with reproducible ELF binary.");
                std::fs::read("../../simple-token/host/target/riscv-guest/riscv32im-risc0-zkvm-elf/docker/method/method")
                      .expect("Could not read ELF binary at target/riscv-guest/riscv32im-risc0-zkvm-elf/docker/method/method")
            } else {
                println!("Running non-reproducibly");
                methods::GUEST_ELF.to_vec()
            };
            let (proof, _) = client_sdk::helpers::prove(&binary, &inputs).await.unwrap();

            let proof_tx = ProofTransaction {
                tx_hashes: vec![blob_tx_hash.clone()],
                proof,
                contract_name: token2.clone().into(),
            };

            // Send the proof transaction
            let proof_tx_hash = client
                .send_tx_proof(&proof_tx)
                .await
                .unwrap()
                .text()
                .await
                .unwrap();
            println!("✅ Proof tx sent. Tx hash: {}", proof_tx_hash);
        }
    }
}
