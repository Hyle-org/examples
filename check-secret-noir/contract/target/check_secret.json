{"noir_version":"1.0.0-beta.2+1a2a08cbcb68646ff1aaef383cfc1798933c1355","hash":5069763197159848502,"abi":{"parameters":[{"name":"version","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"next_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"next_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"identity_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"identity","type":{"kind":"string","length":64},"visibility":"public"},{"name":"tx_hash","type":{"kind":"string","length":64},"visibility":"public"},{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_number","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_contract_name_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"blob_contract_name","type":{"kind":"string","length":64},"visibility":"public"},{"name":"blob_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"tx_blob_count","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"success","type":{"kind":"boolean"},"visibility":"public"},{"name":"password","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"19":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"30":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod bigint;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    /// Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    /// Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"62":{"source":"// Simple Token Contract implementation in Noir\n\nfn main(\n    // The version of the HyleOutput. This is unchecked for now.\n    version: pub u32,\n    // The initial state of the contract. This is the state before the transaction is executed.\n    initial_state_len: pub u32,\n    initial_state: pub [u8; 4],\n    // The state of the contract after the transaction is executed.\n    next_state_len: pub u32,\n    next_state: pub [u8; 4],\n    // The identity used to execute the transaction. This is the same as the one used in the\n    // BlobTransaction.\n    identity_len: pub u8,\n    identity: pub str<64>, // 96\n    // TxHash of the BlobTransaction.\n    tx_hash: pub str<64>,\n    // ------ Blobs ------\n    // The index of the blob being executed.\n    index: pub u32,\n    // Number of blobs used by the contract\n    // If blob_number is > 1, then you need multiple occurence of parameters group \"Blob\"\n    blob_number: pub u32,\n    // --- Blob\n    // At least one blob_index must match the index parameter\n    blob_index: pub u32,\n    blob_contract_name_len: pub u8,\n    blob_contract_name: pub str<64>,\n    blob_len: pub u32,\n    blob: pub [u8; 32],\n    // ---\n    // Number of blobs in the transaction. tx_blob_count >= blob_number\n    tx_blob_count: pub u32,\n    // -------------------\n    // Weither the execution was successful or not. If false, the BlobTransaction will be\n    // settled as failed.\n    success: pub bool,\n    // ------ Private inputs ------\n    password: [u8; 32],\n) {\n    // password = sha256(private_password)\n    // stored_hash = sha256(\"{identity}:{sha256(private_password)}\")\n\n    assert(identity.as_bytes().len() == 64);\n    assert(\":\".as_bytes().len() == 1);\n    assert(password.len() == 32);\n    let mut id: BoundedVec<u8, 64 + 1 + 32> = BoundedVec::new();\n    id.extend_from_slice(identity.as_bytes());\n    id.extend_from_slice(\":\".as_bytes());\n    id.extend_from_slice(password);\n\n    println(f\"Identity: {identity}\");\n    println(f\"Password: {password}\");\n    println(f\"extended id: {id}\");\n\n    // Hash the combined input using SHA-256\n    let input_hash = sha256::sha256_var(id.storage(), 64 + 1 + 32);\n    println(f\"Input Hash: {input_hash}\");\n\n    assert(input_hash == blob);\n\n    assert(success == true);\n    assert(version == 1);\n    assert(identity_len <= 64);\n    assert(initial_state_len == 4);\n    assert(next_state_len == 4);\n    assert(initial_state == [0; 4]);\n    assert(next_state == [0; 4]);\n    assert(blob_len == 32);\n    assert(blob_number == 1);\n    assert(tx_blob_count >= 1);\n    assert(blob_contract_name_len <= 64);\n}\n","path":"/home/bertrand/workspace/examples/check-secret-noir/contract/src/main.nr"},"65":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\n","path":"/home/bertrand/nargo/github.com/noir-lang/sha256/v0.1.0/src/sha256.nr"}},"names":["main"],"brillig_names":["print_unconstrained","print_unconstrained","print_unconstrained","build_msg_block","attach_len_to_msg_block","print_unconstrained","directive_integer_quotient","directive_to_radix","directive_invert"]}