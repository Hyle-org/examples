{"noir_version":"1.0.0-beta.2+1a2a08cbcb68646ff1aaef383cfc1798933c1355","hash":7998251031419193103,"abi":{"parameters":[{"name":"version","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"next_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"next_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"identity_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"identity","type":{"kind":"string","length":256},"visibility":"public"},{"name":"tx_hash","type":{"kind":"string","length":64},"visibility":"public"},{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_number","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_contract_name_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"blob_contract_name","type":{"kind":"string","length":256},"visibility":"public"},{"name":"blob_capacity","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"tx_blob_count","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"success","type":{"kind":"boolean"},"visibility":"public"},{"name":"password","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":null,"error_types":{"1837938722211649573":{"error_kind":"string","string":"extend_from_slice out of bounds"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7b3djiTZcaX7Lrzmhdu/2bzKwWCg0WgGBAhpIGkOcDDQux9vkpXVYmSlszdjr1qekTdCt1i7t7lXbHeLFd9a9n9/9z/+6b//n//13/7wz//zX/7td//l//m/v/vjv/zjP/z7H/7ln89/+7+/S88//T//7X//wz//8u//9u//8K///rv/IuHz+9/90z//j/MfU+w/fv+7//mHP/7T7/5L6n/8/p0/LNLf/nSIydsfr//4r78/t6j9W/T+LWb7FnE8YQtLe9vC6mEL2b+F7t/C9m/hz9hi/G0LP/Svt4j9W+T+LWr/Fr1/i9m+RR77t5D9W+j+LWz/FvtPd+4/3bn/dOf+0537T3fuP921/3TX/tNd+0937T/dtf901/7TXftPd+0/3bX/dNf+0937T3fvP929/3T3/tPd+0937z/dvf909/7T3ftPd+8/3bP/dM/+0z37T/fsP92z/3TP/tM9+0/37D/ds/90z/bTXcexfwvZv4Xu38L2b+H7t4j9W+T+LWr/Fr1/i/2nW/afbtl/umX/6Zb9p1v2n27Zf7pl/+mW/adb9p9u2X+6df/p1v2nW/efbt1/unX/6db9p1v3n27df7p1/+nW/afb9p9u23+6bf/ptv2n2/afbtt/um3/6bb9p9v2n27bf7p9/+n2/afb959u33+6ff/p9v2n2/efbt9/un3/6fb9pzv2n+7Yf7pj/+mO/ad7P6tW+1m12s+q1X5WrfazarWfVav9rFrtZ9VqP6tW+1m12s+q1X5WrfazarWfVav9rFrtZ9VqP6tW+1m12s+q1X5WrfazarWfVav9rFrtZ9VqP6tW+1m12s+q1X5WrfazarWfVav9rFrtZ9VqP6tW+1m12s+q1X5WrfazarWfVav9rFrtZ9VqP6tW+1m12s+q1X5WrfazarWfVev9rFrvZ9V6P6vW+1m1Pnz/FrF/i9y/Re3fovdvsf9072fVej+r1vtZtd7PqvV+Vq33s2q9n1Xr/axa72fVej+r1vtZtd7PqvV+Vq33s2q9n1Xr/axa72fVej+r1vtZtd7PqvV+Vq33s2q9n1Xr/axa72fVej+r1vtZtd7PqvV+Vq33s2q9n1Xr/axa72fVej+r1vtZtd7PqvV+Vq33s2q9n1Xr/axa72fVej+r1vtZtd7PqvV+Vq33s2q9n1Xr/axa72fVej+r1vtZtd7PqvV+Vq33s2q9n1Xr/axa72fVej+r1vtZtd7PqvV+Vq33s2q9n1Xr/axa72fVej+r1vtZtd7PqvV+Vq33s2q9n1Xr/axa72fVej+r1vtZtd7PqvV+Vq33s2q9n1Xr/axa72fVej+r1vtZtd7PqvV+Vq33s2q9n1Xr/axa72fVej+rNvtZtdnPqs1+Vm32s2pz+P4tYv8WuX+L2r9F799i/+nez6rNflZt9rNqs59Vm/2s2uxn1WY/qzb7WbXZz6rNflZt9rNqs59Vm/2s2uxn1WY/qzb7WbXZz6rNflZt9rNqs59Vm/2s2uxn1WY/qzb7WbXZz6rNflZt9rNqs59Vm/2s2uxn1WY/qzb7WbXZz6rNflZt9rNqs59Vm/2s2uxn1WY/qzb7WbXZz6rNflZt9rNqs59Vm/2s2uxn1WY/qzb7WbXZz6rNflZt9rNqs59Vm/2s2uxn1WY/qzb7WbXZz6rNflZt9rNqs59Vm/2s2uxn1WY/qzb7WbXZz6rNflZt9rNqs59Vm/2s2uxn1WY/qzb7WbXZz6rNflZt9rNqs59Vm/2s2uxn1WY/qzb7WbXZz6rNflZt9rNqs59Vm/2s2uxn1WY/qzb7WbXZz6rNflZNjv2w2rmHAPZQwB4G2MMBewRgjwTsUYA9GrAH4JwL4JwL4JwL4JwL4JwL4JwL4JwL4JwL4JwL4JwL4Jwr4Jwr4Jwr4Jwr4Jwr4Jwr4Jwr4Jwr4Jwr4Jwr4Jwb4Jwb4Jwb4Jwb4Jwb4Jwb4Jwb4Jwb4Jwb4Jwb4Jw74Jw74Jw74Jw74Jw74Jw74Jw74Jw74Jw74Jw74JwH4JwH4JwH4JwH4JwH4JwH4JwH4JwH4JwH4JwH4Jwn4Jwn4Jwn4Jwn4Jwn4Jwn4Jwn4Jwn4Jwn4Jwn4JwX4JwX4JwX4JwX4JwX4JwX4JwX4JwX4JwX4JwX4Jw34Jw34Jw34Jw34Jw34Jw34Jw34Jw34Jw34Jw34JwP4JwP4JwP4JwP4JwP4JwP4JwP4JwP4JwP4JwDeDgB8HAC4OEEwMMJgIc7xVfAHgHYIwF7FGCPBuwBOOcAHk4APJwAeDgB8HAC4OEEwMMJgIcTAA8nAB5OADycAHg4AfBwAuDhBMDDCYCHEwAPJwAeTgA8nAB4OAHwcALg4QTAwwmAhxMADycAHk4APJwAeDgB8HAC4OEEwMMJgIcTAA8nAB5OADycAHg4AfBwAuDhBMDDCYCHEwAPJwAeTgA8nAB4OAHwcALg4QTAwwmAhxMADycAHk4APJwAeDgB8HAC4OEEwMMJgIcTAA8nAB5OADycAHg4AfBwAuDhBMDDCYCHEwAPJ8/h4dLe9rCShz0CsEcC9ijAHoBzDuDhBMDDCYCHEwAPJwAeTgA8nAB4OAHwcALg4QTAwwmAhxMADycAHk4APJwAeDgB8HAC4OEEwMMJgIcTAA8nAB5OATycAng4BfBwCuDh9HDAHgHYIwF7FGCPBuwBOOcAHk4BPJwCeDgF8HAK4OEUwMMpgIdTAA+nAB5OATycAng4BfBwCuDhFMDDKYCHUwAPpwAeTgE8nAJ4OAXwcArg4RTAwymAh1MAD6cAHk4BPJwCeDgF8HAK4OEUwMMpgIdTAA+nAB5OATycAng4BfBwCuDhFMDDKYCHUwAPpwAeTgE8nAJ4OAXwcArg4RTAwymAh1MAD6cAHk4BPJwCeDgF8HAK4OEUwMMpgIdTAA+nAB5OATycAng4BfBwCuDhFMDDKYCHUwAPp4B8OAXkwykgH04B+XAK4OEUwMMpgIdTAA+nAB5OATycAng4BfBwCuDhFMDDKYCHUwAPpwAeTgE8nAJ4OAXwcArg4RTAwymAh1MAD6cAHk4BPJwBeDgD8HAG4OEMwMPZ4YA9ArBHAvYowB4N2ANwzgE8nAF4OAPwcAbg4QzAwxmAhzMAD2cAHs4APJwBeDgD8HAG4OEMwMMZgIczAA9nAB7OADycAXg4A/BwBuDhDMDDGYCHMwAPZwAezgA8nAF4OAPwcAbg4QzAwxmAhzMAD2cAHs4APJwBeDgD8HAG4OEMwMMZgIczAA9nAB7OADycAXg4A/BwBuDhDMDDGYCHMwAPZwAezgA8nAF4OAPwcAbg4QzAwxmAhzMAD2cAHs4APJwBeDgD8HAG4OEMwMMZgIczAA9nAB7OADycAXg4A/BwBuDhDMDDGYCHMwAPZwAezgA8nAF4OAPwcAbg4QzAwxmAhzMAD2cAHs4APJwBeDgD8HAG4OEMwMMZgIczAA9nAB7OADycAXg4B/BwDuDhHMDDOYCH88MBewRgjwTsUYA9GrAH4JwDeDgH8HAO4OEcwMM5gIdzAA/nAB7OATycA3g4B/BwDuDhHMDDOYCHcwAP5wAezgE8nAN4OAfwcA7g4RzAwzmAh3MAD+cAHs4BPJwDeDgH8HAO4OEcwMM5gIdzAA/nAB7OATycA3g4B/BwDuDhHMDDOYCHcwAP5wAezgE8nAN4OAfwcA7g4RzAwzmAh3MAD+cAHs4BPJwDeDgH8HAO4OEcwMM5gIdzAA/nAB7OATycA3g4B/BwDuDhHMDDOYCHcwAP5wAezgE8nAN4OAfwcA7g4RzAwzmAh3MAD+cAHs4BPJwDeDgH8HAO4OEcwMM5gIdzAA/nAB7OATycA3g4B/BwDuDhHMDDOYCHcwAP5wAezgE8nAN4OAfwcAHg4QLAwwWAhwsADxeHA/YIwB4J2KMAezRgD8A5B/BwAeDhAsDDBYCHCwAPFwAeLgA8XAB4uADwcAHg4QLAwwWAhwsADxcAHi4APFwAeLgA8HAB4OECwMMFgIcLAA8XAB4uADxcAHi4APBwAeDhAsDDBYCHCwAPFwAeLgA8XAB4uADwcAHg4QLAwwWAhwsADxcAHi4APFwAeLgA8HAB4OECwMMFgIcLAA8XAB4uADxcAHi4APBwAeDhAsDDBYCHCwAPFwAeLgA8XAB4uADwcAHg4QLAwwWAhwsADxcAHi4APFwAeLgA8HAB4OECwMMFgIcLAA8XAB4uADxcAHi4APBwAeDhAsDDBYCHCwAPFwAeLgA8XAB4uADwcAHg4QLAwwWAhwsADxcAHi4APFwAeLgA8HAB4OESwMMlgIdLAA+XAB4uDwfsEYA9ErBHAfZowB6Acw7g4RLAwyWAh0sAD5cAHi4BPFwCeLgE8HAJ4OESwMMlgIdLAA+XAB4uATxcAni4BPBwCeDhEsDDJYCHSwAPlwAeLgE8XAJ4uATwcAng4RLAwyWAh0sAD5cAHi4BPFwCeLgE8HAJ4OESwMMlgIdLAA+XAB4uATxcAni4BPBwCeDhEsDDJYCHSwAPlwAeLgE8XAJ4uATwcAng4RLAwyWAh0sAD5cAHi4BPFwCeLgE8HAJ4OESwMMlgIdLAA+XAB4uATxcAni4BPBwCeDhEsDDJYCHSwAPlwAeLgE8XAJ4uATwcAng4RLAwyWAh0sAD5cAHi4BPFwCeLgE8HAJ4OESwMMlgIdLAA+XAB4uATxcAni4BPBwCeDhEsDDFYCHKwAPVwAergA8XB0O2CMAeyRgjwLs0YA9AOccwMMVgIcrAA9XAB6uADxcAXi4AvBwBeDhCsDDFYCHKwAPVwAergA8XAF4uALwcAXg4QrAwxWAhysAD1cAHq4APFwBeLgC8HAF4OEKwMMVgIcrAA9XAB6uADxcAXi4AvBwBeDhCsDDFYCHKwAPVwAergA8XAF4uALwcAXg4QrAwxWAhysAD1cAHq4APFwBeLgC8HAF4OEKwMMVgIcrAA9XAB6uADxcAXi4AvBwBeDhCsDDFYCHKwAPVwAergA8XAF4uALwcAXg4QrAwxWAhysAD1cAHq4APFwBeLgC8HAF4OEKwMMVgIcrAA9XAB6uADxcAXi4AvBwBeDhCsDDFYCHKwAPVwAergA8XAF4uALwcAXg4QrAwxWAh2sAD9cAHq4BPFwDeLg+HLBHAPZIwB4F2KMBewDOOYCHawAP1wAergE8XAN4uAbwcA3g4RrAwzWAh2sAD9cAHq4BPFwDeLgG8HAN4OEawMM1gIdrAA/XAB6uATxcA3i4BvBwDeDhGsDDNYCHawAP1wAergE8XAN4uAbwcA3g4RrAwzWAh2sAD9cAHq4BPFwDeLgG8HAN4OEawMM1gIdrAA/XAB6uATxcA3i4BvBwDeDhGsDDNYCHawAP1wAergE8XAN4uAbwcA3g4RrAwzWAh2sAD9cAHq4BPFwDeLgG8HAN4OEawMM1gIdrAA/XAB6uATxcA3i4BvBwDeDhGsDDNYCHawAP1wAergE8XAN4uAbwcA3g4RrAwzWAh2sAD9cAHq4BPFwDeLgG8HAN4OEawMM1gIdrAA83AB5uADzcAHi4AfBwczhgjwDskYA9CrBHA/YAnHMADzcAHm4APNwAeLgB8HAD4OEGwMMNgIcbAA83AB5uADzcAHi4AfBwA+DhBsDDDYCHGwAPNwAebgA83AB4uAHwcAPg4QbAww2AhxsADzcAHm4APNwAeLgB8HAD4OEGwMMNgIcbAA83AB5uADzcAHi4AfBw8xweLu1tDyt52KMBe8z+PZ7Dw13sATjnAB5unsPDXdwrB+wRgD0SsAfgfQ7g4SYA5zwB5/w5PNzFHgrYA/A+B/Bwk4BznoBznoD3eQLe5wAebgA83BTgnBfgnBfgff4cHu5iD0DfDuDhpgDnvADnvADv8wa8zwE83AB4uGnAOW/AOW/A+7wB73MADzcAHm4acM4HcM4H8D4fwPscwMMNgIebAZzzAZzzAbzPB/A+38/D6bGfhzv32H7Ozz0UsIcB9nDAHgH4O0/AHgW4Vw3YY/bvIQdgD9n/d76fhzv3AJxzAZxzCcAeCdijAH/nDdgDcM4VcM4V8D5XwPt8Pw937uGAPQDnXAHnXAHvcwW8zxXQtxugbzfAOTfAOTfA+/w5PNzFHoC+3QB9uwHOuQHOuQHe5w54nzugb3dA3+6Ac+6Ac+6A97kD3ucO6Nsd0Lc74JwH4JwH4H0egPd5APr2/flw5x6Acx6Acx6A93kA3ucB6NsT0Lcn4Jwn4Jwn4H3+HB7uYg9A356Avj0B5zwB5zwB7/MCvM8L0LcXoG8vwDkvwDkvwPu8AO/zAvTtBejbC3DOG3DOG/A+b8D7vAF9+/58uHMPwDlvwDlvwPu8Ae/zBvTtA+jbB3DOB3DOB/A+fw4Pd7EHoG8fQN8+gHM+gHM++9/nchyAPfb37bI/H+7cwwD3ygF7BGCPBOxRgL/zBuwBOOcAHk5EAHsoYI/9fbvsz4c79wCccwAPJ1KAPRqwx/6+Xfbnw517AM45gIcTBbzPn8PDXewRgL/zBOwBOOcAHk4U8D43wPvcAH27Afp2AA8nAB5ODPA+N8D73AB9uwH6dgAPJwAeThzwPnfA+9wBffv+fLhzD8A5B/Bw4oD3uQPe5w7o2wPQtwN4OAHwcBKA9/n+fLhzD0DfHoC+HcDDCYCHkwC8zxPwPk9A356Avh3AwwmAh5MEvM8T8D5PQN+egL4dwMMJgIeTArzPC/A+L0Dfvn9e6rkH4JwDeDgpwPu8AO/zAvTtDejbATycAHg4acD7fH8+3LkHoG9vQN8O4OEEwMNJA97nA3ifD6BvH0DfDuDhBMDDyQDe5wN4nw+gbx9A3w7g4RTAwykgH04B+XC6f17quYcD9gjAvUrAHgXYowF77O/bdf+81HMPwDkH8HAKyIdTQD6c7p+Xeu6RgD0A5xzAwykgH04B+XC6f17quYcC9gCccwAPp4B8OAXkw+n+eannHg3YA3DOATycAvLhFJAPpwbo2/fPSz33AJxzAA+ngHw4BeTDqQH6dgf07QAeTgE8nALy4RSQD6cO6Nsd0LcDeDgF8HAKyIdTQD6cBqBvD0DfDuDhFMDDKSAfTgH5cBqAvj0AfTuAh1MAD6eAfDgF5MNpAvr2/fNSzz0A5xzAwykgH04B+XCagL69AH07gIdTAA+ngHw4BeTDaQH69gL07QAeTgE8nALy4RSQD6cN6Nsb0LcDeDgF8HAKyIdTQD6cNqBvb0DfDuDhFMDDKSAfTgH5cDqAvn3/vNRzD8A5B/BwCsiHU0A+nALmpRpgXqoBeDgD8HAGyIezwwF7BODvPAF7FOBeNWCP/e9zA+TDGWBeqgHmpRqAhzMAD2eAfDgD5MMZYF6qAealGoCHMwAPZ4B8OAPkwxlgXqoB5qUagIczAA9ngHw4A+TDGWBeqgHmpRqAhzMAD2eAfDgD5MMZYF6qAealGoCHMwAPZ4B8OAPkwxlgXqoB5qUagIczAA9ngHw4A+TDGWBeqgHmpRqAhzMAD2eAfDgD5MMZYF6qAealGoCHMwAPZ4B8OAPkwxlgXqoB5qUagIczAA9ngHw4A+TDGWBeqgHmpRqAhzMAD2eAfDgD5MMZYF6qAealGoCHMwAPZ4B8OAPkwxlgXqoB5qUagIczAA9ngHw4A+TDGWBeqgHmpRqAhzMAD2eAfDgD5MMZYF6qAealGoCHMwAPZ4B8OAPkwxlgXqoB5qUagIczAA9ngHw4B+TDOWBeqgPmpTqAh/PDAXsEYI8E7FGAv/MG7AE45wAezgH5cA7Ih3PAvFQHzEt1AA/nAB7OAflwDsiHc8C8VAfMS3UAD+cAHs4B+XAOyIdzwLxUB8xLdQAP5wAezgH5cA7Ih3PAvFQHzEt1AA/nAB7OAflwDsiHc8C8VAfMS3UAD+cAHs4B+XAOyIdzwLxUB8xLdQAP5wAezgH5cA7Ih3PAvFQHzEt1AA/nAB7OAflwDsiHc8C8VAfMS3UAD+cAHs4B+XAOyIdzwLxUB8xLdQAP5wAezgH5cA7Ih3PAvFQHzEt1AA/nAB7OAflwDsiHc8C8VAfMS3UAD+cAHs4B+XAOyIdzwLxUB8xLdQAP5wAezgH5cA7Ih3PAvFQHzEt1AA/nAB7OAflwDsiHc8C8VAfMS3UAD+cAHs4B+XAOyIdzwLxUB8xLdQAPFwAeLgD5cAHIhwvAvNQ4HLBHAO5VAvYowB4N2GN/3x6AeakB4OECwMMFIB8uAPlwAZiXGoB5qQHg4QLAwwUgHy4A+XABmJcagHmpAeDhAsDDBSAfLgD5cAGYlxqAeakB4OECwMMFIB8uAPlwAZiXGoB5qQHg4QLAwwUgHy4A+XABmJcagHmpAeDhAsDDBSAfLgD5cAGYlxqAeakB4OECwMMFIB8uAPlwAZiXGoB5qQHg4QLAwwUgHy4A+XABmJcagHmpAeDhAsDDBSAfLgD5cAGYlxqAeakB4OECwMMFIB8uAPlwAZiXGoB5qQHg4QLAwwUgHy4A+XABmJcagHmpAeDhAsDDBSAfLgD5cAGYlxqAeakB4OECwMMFIB8uAPlwAZiXGoB5qQHg4QLAwwUgHy4A+XABmJcagHmpAeDhAsDDBSAfLgD5cAGYl5qAeakJ4OESwMMlIB8uDwfsEYC/8wTsUYB71YA99r/PE5APl4B5qQmYl5oAHi4BPFwC8uESkA+XgHmpCZiXmgAeLgE8XALy4RKQD5eAeakJmJeaAB4uATxcAvLhEpAPl4B5qQmYl5oAHi4BPFwC8uESkA+XgHmpCZiXmgAeLgE8XALy4RKQD5eAeakJmJeaAB4uATxcAvLhEpAPl4B5qQmYl5oAHi4BPFwC8uESkA+XgHmpCZiXmgAeLgE8XALy4RKQD5eAeakJmJeaAB4uATxcAvLhEpAPl4B5qQmYl5oAHi4BPFwC8uESkA+XgHmpCZiXmgAeLgE8XALy4RKQD5eAeakJmJeaAB4uATxcAvLhEpAPl4B5qQmYl5oAHi4BPFwC8uESkA+XgHmpCZiXmgAeLgE8XALy4RKQD5eAeakJmJeaAB4uATxcAvLhCpAPV4B5qQWYl1oAHq4OB+wRgD0SsEcB/s4bsAfgnAN4uALkwxUgH64A81ILMC+1ADxcAXi4AuTDFSAfrgDzUgswL7UAPFwBeLgC5MMVIB+uAPNSCzAvtQA8XAF4uALkwxUgH64A81ILMC+1ADxcAXi4AuTDFSAfrgDzUgswL7UAPFwBeLgC5MMVIB+uAPNSCzAvtQA8XAF4uALkwxUgH64A81ILMC+1ADxcAXi4AuTDFSAfrgDzUgswL7UAPFwBeLgC5MMVIB+uAPNSCzAvtQA8XAF4uALkwxUgH64A81ILMC+1ADxcAXi4AuTDFSAfrgDzUgswL7UAPFwBeLgC5MMVIB+uAPNSCzAvtQA8XAF4uALkwxUgH64A81ILMC+1ADxcAXi4AuTDFSAfrgDzUgswL7UAPFwBeLgC5MMVIB+uAPNSCzAvtQA8XAN4uAbkwzUgH64B81L7cMAeAbhXCdijAHs0YI/9fXsD5qU2gIdrAA/XgHy4BuTDNWBeagPmpTaAh2sAD9eAfLgG5MM1YF5qA+alNoCHawAP14B8uAbkwzVgXmoD5qU2gIdrAA/XgHy4BuTDNWBeagPmpTaAh2sAD9eAfLgG5MM1YF5qA+alNoCHawAP14B8uAbkwzVgXmoD5qU2gIdrAA/XgHy4BuTDNWBeagPmpTaAh2sAD9eAfLgG5MM1YF5qA+alNoCHawAP14B8uAbkwzVgXmoD5qU2gIdrAA/XgHy4BuTDNWBeagPmpTaAh2sAD9eAfLgG5MM1YF5qA+alNoCHawAP14B8uAbkwzVgXmoD5qU2gIdrAA/XgHy4BuTDNWBeagPmpTaAh2sAD9eAfLgG5MM1YF5qA+alNoCHawAP14B8uAbkwzVgXuoA5qUOgIcbAA83gHy4ORywRwD+zhOwRwHuVQP22P8+H0A+3ADmpQ5gXuoAeLgB8HADyIcbQD7cAOalDmBe6gB4uAHwcAPIhxtAPtwA5qUOYF7qAHi4AfBwA8iHG0A+3ADmpQ5gXuoAeLgB8HADyIcbQD7cAOalDmBe6gB4uAHwcAPIhxtAPtwA5qUOYF7qAHi4AfBwA8iHG0A+3ADmpQ5gXuoAeLgB8HADyIcbQD7cAOalDmBe6gB4uAHwcAPIhxtAPtwA5qUOYF7qAHi4AfBwA8iHG0A+3ADmpQ5gXuoAeLgB8HADyIcbQD7cAOalDmBe6gB4uAHwcAPIhxtAPtwA5qUOYF7qAHi4AfBwA8iHG0A+3ADmpQ5gXuoAeLgB8HADyIcbQD7cAOalDmBe6gB4uAHwcAPIhxtAPtwA5qUOYF7qAHi4AfBwsz8fzo79+XDnHtv79nMPBexhgHvlgD0CsEcC9ijA33kD9gCccwGc8/35cOceCtjD9v+d75+Xeu4BOOcCOOf78+HOPRqwx+z/O98/L/XcA3DOFXDOFfA+358Pd+4RgL/zBOwBOOcKOOcKeJ8b4H1ugL7dAH27Ac65Ac65Ad7nBnifG6BvN0DfboBz7oBz7oD3uQPe5w7o2/fPSz33AJxzB5xzB7zPHfA+d0DfHoC+PQDnPADnPADv8/35cOcegL49AH17AM55AM55AN7nCXifJ6BvT0DfnoBznoBznoD3eQLe5wno2xPQtyfgnBfgnBfgfV6A93kB+vb981LPPQDnvADnvADv8wK8zwvQtzegb2/AOW/AOW/A+3x/Pty5B6Bvb0Df3oBz3oBz3oD3+QDe5wPo2wfQtw/gnA/gnA/gfT6A9/kA+vYB9O0AHk4APJzsz4c791DAHvv7djkcsEcA7lUC9ijAHg3YY3/fLvvnpZ57AM45gIeT/flw5x4O2CMAf+cJ2ANwzgE8nAjgfa6A9/n+eannHgrYA3DOATycKOB9roD3+f55qeceDdgDcM4BPJwY4H1ugPe5Afr2/fNSzz0A5xzAw4kB3ucGeJ8boG93QN8O4OEEwMOJA97n+/Phzj0AfbsD+nYADycAHk4c8D4PwPs8AH17APp2AA8nAB5OAvA+D8D7PAB9ewD6dgAPJwAeThLwPk/A+zwBffv+eannHoBzDuDhJAHv8wS8zxPQtxegbwfwcALg4aQA7/P9+XDnHoC+vQB9O4CHEwAPJwV4nzfgfd6Avr0BfTuAhxMADycNeJ834H3egL69AX07gIcTAA8nA3ifD+B9PoC+ff+81HMPwDkH8HAygPf5AN7n++elmu6fl3rusf+cK4CHU0A+nB4O2CMAf+cJ2KMA96oBe+x/nysgH073z0s991DAHoBzDuDhFJAPp4B8ON0/L/XcowF7AM45gIdTQD6cAvLhdP+81HMPB+wBOOcAHk4B+XAKyIdTBfTtBujbATycAng4BeTDKSAfTg3QtxugbwfwcArg4RSQD6eAfDh1QN/ugL4dwMMpgIdTQD6cAvLh1AF9uwP6dgAPpwAeTgH5cArIh9MA9O3756WeewDOOYCHU0A+nALy4TQAfXsC+nYAD6cAHk4B+XAKyIfTBPTtCejbATycAng4BeTDKSAfTgvQtxegbwfwcArg4RSQD6eAfDgtQN9egL4dwMMpgIdTQD6cAvLhtAF9+/55qecegHMO4OEUkA+ngHw4bUDfPoC+HcDDKYCHU0A+nALy4XQAffsA+nYAD6cAHk4B+XAGyIczwLxUA8xLNQAPZ4cD9gjAHgnYowB/5w3YA3DOATycAfLhDJAPZ4B5qQaYl2oAHs4APJwB8uEMkA9ngHmpBpiXagAezgA8nAHy4QyQD2eAeakGmJdqAB7OADycAfLhDJAPZ4B5qQaYl2oAHs4APJwB8uEMkA9ngHmpBpiXagAezgA8nAHy4QyQD2eAeakGmJdqAB7OADycAfLhDJAPZ4B5qQaYl2oAHs4APJwB8uEMkA9ngHmpBpiXagAezgA8nAHy4QyQD2eAeakGmJdqAB7OADycAfLhDJAPZ4B5qQaYl2oAHs4APJwB8uEMkA9ngHmpBpiXagAezgA8nAHy4QyQD2eAeakGmJdqAB7OADycAfLhDJAPZ4B5qQaYl2oAHs4APJwB8uEMkA9ngHmpBpiXagAezgA8nAHy4QyQD2eAeakGmJdqAB7OATycA/LhHJAP54B5qX44YI8A3KsE7FGAPRqwx/6+3QHzUh3AwzmAh3NAPpwD8uEcMC/VAfNSHcDDOYCHc0A+nAPy4RwwL9UB81IdwMM5gIdzQD6cA/LhHDAv1QHzUh3AwzmAh3NAPpwD8uEcMC/VAfNSHcDDOYCHc0A+nAPy4RwwL9UB81IdwMM5gIdzQD6cA/LhHDAv1QHzUh3AwzmAh3NAPpwD8uEcMC/VAfNSHcDDOYCHc0A+nAPy4RwwL9UB81IdwMM5gIdzQD6cA/LhHDAv1QHzUh3AwzmAh3NAPpwD8uEcMC/VAfNS/Qc8XMr3PWw+3mM66i9/eLr8YQfdvoNt38G37xB//w4T/W2H6ccdcvsOtX2H3r7D7N7hB/TbM3eQ7Tvo9h1s+w6+fYftZ7q3n+nefqZ7+5nu7Wd6tp/p2X6mZ/uZnu1neraf6dl+pmf7mZ7tZ3q2n+nZfabjOLbvINt30O072PYdfPsOsX2H3L5Dbd+ht++w/UzL9jMt28+0bD/Tsv1My/YzLdvPtGw/07L9TMv2My3bz7RuP9O6/Uzr9jOt28+0bj/Tuv1M6/YzrdvPtG4/07r9TNv2M23bz7RtP9O2/Uzb9jNt28+0bT/Ttv1M2/YzbdvPtG8/0779TPv2M+3bz7RvP9O+/Uz79jPt28+0bz/Tvv1Mx/YzHdvPdGw/07H9TMf2Mx3bz3RsP9Ox/UzH9jMd2890bj/Tuf1M5/YzndvPdG4/07n9TOf2M53bz3RuP9O5/UzX9jNd2890bT/Ttf1M1/YzvZ0ji+0cWWznyGI7RxbbObLYzpHFdo4stnNksZ0ji+0cWWznyGI7RxbbObLYzpHFdo4stnNksZ0ji+0cWWznyGI7RxbbObLYzpHFdo4stnNksZ0jy+0cWW7nyHI7R5bbObI8fPsOsX2H3L5Dbd+ht++w/Uxv58hyO0eW2zmy3M6R5XaOLLdzZLmdI8vtHFlu58hyO0eW2zmy3M6R5XaOLLdzZLmdI8vtHFlu58hyO0eW2zmy3M6R5XaOLLdzZLmdI8vtHFlu58hyO0eW2zmy3M6R5XaOLLdzZLmdI8vtHFlu58hyO0eW2zmy3M6R5XaOLLdzZLmdI8vtHFlu58hyO0eW2zmy3M6R5XaOLLdzZLmdI8vtHFlu58hyO0eW2zmy3M6R5XaOLLdzZLmdI8vtHFlu58hyO0eW2zmy3M6R5XaOLLdzZLmdI8vtHFlu58hyO0eW2zmy3M6R5XaOLLdzZLmdI8vtHFlu58hyO0eW2zmy3M6R5XaOLLdzZLmdI8vtHFlu58hyO0eW2zmy3M6R5XaOLLdzZLmdI8vtHFlu58hyO0dW2zmy2s6R1XaOrLZzZHX49h1i+w65fYfavkNv32H7md7OkdV2jqy2c2S1nSOr7RxZbefIajtHVts5strOkdV2jqy2c2S1nSOr7RxZbefIajtHVts5strOkdV2jqy2c2S1nSOr7RxZbefI6kccWcrbDi0XO7S87dB+POxg23fwJ+zw0RyO+hFH9sQdcvsOtX2H/vt3uPi0zu4dfsSR/aYdSr7vYA87yPYddPtdsu3X4Nt3iO13KbdfQ23fYfuZ9tl9DbH9TIfsvkuh269h+5kO336XYvs1bD/TUdvvUm+/hu1nOo/ddym3v6dz+5lO236Xtr+nc/uZztx+l7a/p3P7mc7tvXdtf0/X9jNd23vv2v6eru1nurb33rX9PV3bz3Rt771r+3u6t5/p3t579/b3dG8/07299+7t7+nefqZ7e+/d29/Tvf1Mz/bee7a/p2f7mZ7tvfdsf0/P9jM923vv2f6enu1nenb33n3sfk/3Idt30O13ybZfg2/fIbbfpdx+DbV9h95+l3a/p1u2n2nZ3Xu36PZr2H6mxbffpdh+DdvPtNT2u9Tbr2H7mdbdvXfr9ve0bj/Tatvv0vb3tG4/05rb79L297RuP9O6vfe27e9p236mbXvv/SOObL4tkrLjYoeyb3/2OOLtz57L/rzD+2e6LN92yP77dnj/TJ+K+7dV51eMv2+H98/0HPFt1dh/2uHPq2pp1ftnr0u/r/KPr0Ym3/76puv7H46/bDHbt/gB8fXULWT/Fvp3b6Ehx1/+sEbE4xa2fwvfv0Xs3yL3b1H7t+j9W8z2LeLYv4Xs32L/6Y79pzv2n+7Yf7pj/+mO/ac79p/u2H+68xmn+62v1Zh3tpD9W+j+LWz/Fk843eePNd+2OJ8Wv97i8Q93+bd6zn987IgywPVEfvvD5+mqj/+wuPubh8c937mdee/yC1x+vn2H6pzjsZ4mq2e46qmDrB7hepqUouux462e//yH/1yPkdXjt35c1b1fFpVkp5fs6V9kT/8ie/r3wfW0beF6ujXZ07/hT/+2t3pmHutxsnqCrJ4kq6fI6ulbv357bl3+kPX+I2T1KFk9RlaPc3UPE1xv60myesie/tNk9QxVPXMcZPUIWT1KVg9Xdz4H+vnsx7f/crvJYz1BVk+S1VN3bifnuHUzPweXNjPC1Z2PcHXnI1zd+YhRdcMjTtV9jnB15yNc2swIV3c+wtWdj5B150rWnStZd65k3bnardsT9XuXH1xva+X65XSU65fTUa5fTkeHq7uyg6ubMa5fTsfInv5Gps2Yk9XD9cvpGFl3bmTduZF153brn0LHj3uXT6bNOJk241y/nI47WT3B1V051y+n40VWD9nT38m0mSDTZoJMmwmy7jzIuvNwsnpujalP3NrTNEGmzQSZNhNkv5wm2S+nyeVpmuSi2ie5PE2TZE//JNNmkkybSTJtJsm68yTrzousO4d7Tn/Ngcnj8wfuOb2qx8jqcbJ6gqyeJKunyOppsnqGqx64K/SqHrLnc5M9n5vs+dxkz+cmez432fO5yZ7PTfZ8brLn8/zM5/M7voURsnrQz+fnyo1zb1AR7gq9UN+GjDwcMvJwyNRtvCv0Y7UU7wr9SJ3046AiD896qH7bPOuh+m3zrIfqt82zHierh0rdPuuhUrfPeqjU7bOeO9s8z/LvDCr6weUKPeuhIg/PeqjIw7MeKvLwrMeZuquzHipX6FkPFXl41kP29OdyhZ71UP22eQoTVL9tnvWQdedcrtCzHrLu/NY2z7P8O4OKZ/lU2sxZD5U2c9ZDRR6e9VCRh34YVZ7uWQ+VK/Ssh4o8POshe/pzuULPesi0GS5X6FkPWXfO5Qo96yHrzm9t8zzLl3uXT6bNcLlCz3qcrB6qX07PepKru+JyhZ71NFk9ZE9/LlfoWQ+ZNsPlCj3rIevOuVyhZz1k3XlQcY1nPVRc41kPFdd41kPFNfqRVFzjWQ8V13jWA+fO460f83g873Df5lU9TlZPkNVzZxv+Wf6d49HP8sm0c65JpH5wTSI96yEjW/CTSD/+9ss1ifSsx8nqIevOi0w7LzLtvMi08yJTT5pMPWky9aTv7Do6y7+z6+gs37ne1k2mnTcZ2dJkZEtTuY7OeshcR0PmOhqyp/+QaedDpp3jZ4Ve1EPWnQ9Zd841K/Ss596uo7m160gOLm1GDi5tRg4uskUOLrJFDqfqruTgch3JweU6EjLPqRxc2owcXNqMCJc2I8LVnYtwdeciXN25wF2hz21P5NauIxEubUaES5sR4frlVITrl1NRLteRKJfrSJTLdSRknlOBe06v6uHSZkS5tBlRsu5cybpzJevOjSpP96yHKk/3rIcqT/eshypP96zHyer5mXm6j1ysWJLVA+fOP+Q+Be4KvapnuOqBu0Kv6rm1zVP81iCMkLlChcwVKmSuUHEy9QTvCv342ziZK1Sci2wRMleokLlChcwVKmSuUCFzhQqZK1SCTD2JW9uIJG4NwgjXrFAXrlmhZz1kZEuSkS34WaEfd1f4WaEfdzNJRrZwzQo96yHTzrlmhZ71kGnnXLNCz3rIuvMi687r1jYigZtIn1w+mTZTZNpMkZEtRUa24D2nH3dXzeU6kiYjW5rs6d9k2gzcFXpVD5k202TdeZN1503Wnfe9bURz6/hdGTJtZsi0mSH75ZRrEulZT3B1V0PmOhquPF0Zsqf/cGkzenBpM0o2iVTJJpEq2SRSPbi6cz1+Jtf4yFnqwZWnqwdXnq4eXHm6enDl6apw5emqcOXpqnDl6apw5ekq3BV6VQ9Xnq7KrfN0VW4NwiiZK1TJXKGqXGSLKpd6osqVp6vKlaereFfoRT1c2rmSuUKVzBWqZK5QJXOFqpGpJ0amntitbURqtwZhFO45vXhbGxfZosZFtqhxkS1qXHm6alyuI3UuskWd7OnvZNq5k2nncFfoVT1k3bmTdedO1p37rW1E6rcGYTTItJkg02aCi2zR4CJbFO85/bi7Ci7XkQYX2aJB9vQPMm0myLSZJNNmkqw7T7LuPMm6c7gr9LntSd46T1eTTJtJMm2GbBKpkk0i1eLK09Xich1pceXpapE9/fGTSC/qIdNmyCaRKtkkUiWbRKpkk0i1ufJ0tbnydLW58nS1ufJ0Fe4KvaqHK09XmytPV5srT1ebK09XmytPV4crT1fn1nm6OvcGYchcoUrmCtUhI1uGTD0ZrjxdHa48XR0ussXIXKFG5go1MleokblC7XCyerjUEzu41BM7bm0jsuPWIIwdXNq5CRfZYsJFtphwkS0mXHm6BvecXnQzwkW2mJA9/YVLOzfh0s5NuLRzU7LuXMm6cyXrzvXWNiKDm0ifXD6XNmPKpc2YcpEtplxkiylXnq4Zl+vIjItsMSN7+huZNgN3hV7VQ6bNGFl3bmTduZF153ZrG5H5rfN0zcm0GSfTZsgmkRrZJFJzrjxdcy7XkTlXnq452dPfybQZskmkRjaJ1MgmkRrZJFIjm0RqwZWna8GVp2vBladrwZWna8GVp2vJladryZWna8mVp2vJladrcFfoVT1cebqWt87Ttbw3CEPmCjUyV6gVGdlSZOpJceXpWnHl6RreFXpRD5l2TuYKNTJXqJG5Qo3MFWpNpp40mXrSt7YRWd8bhIF7Ti/e1k1GtjQZ2dJkZEtz5elak7mOhoxsGbKn/5Bp50OmncNdoVf1kHXnQ9adD1l3Pve2Ec2tQRg/uLQZP7i0GT+4yBY/uMgWP5yqu/KDy3XkBxfZ4gfX098PLm3GDy5txoVLm3Hh6s5duLpzF67u3OGu0Oe2J3LrPF0XLm3GhUubcbJJpE42idSVK0/Xlct15MqVp+tK9vTHTyK9qIdLm3GySaRONonUySaROtkkUjeuPF03rjxdN648XTeuPF2Hu0Kv6uHK03XjytN148rTdePK03XjytN158rTdb91nq77rUEYJ3OFOpkr1J2LbHEnU0+cK0/XnStP152LbHEyV6iTuUKdzBXqZK5QJ3OFepCpJ0GmnsStbUQetwZhPMi08yQjW5KMbEkysiW58nQd7jm96GaSjGxJsqd/kmnnSaadJ5l2XmTdeZF150XWndetbUQON5E+uXwybabItJkiI1uKjGwprjxdby7XkTcZ2dJkT/8m02bgrtCresi0mSbrzpusO2+y7rzvbSOaW+fp+pBpM0OmzZBNInWySaQ+XHm6PmSuo+HK0/Uhe/oPlzYTZJNIg2wSaZBNIg2ySaRxcHXncXDl6cbBlacbB1eebhxcebpxcOXphnDl6YZw5emGcOXphnDl6QbcFXpVD1eebsit83RDbg3CBJkrNMhcoaFcZEsol3oSypWnG8qVpxt4V+hFPVzaeZC5QoPMFRpkrtAgc4WGkaknRqae2K1tRGG3BmEC7jm9eFsbF9kSxkW2hHGRLWFcebphXK6jcC6yJZzs6e9k2rmTaedwV+hVPWTduZN1507WnfutbUThtwZhIsi0mSDTZoKLbIngIlsC7zn9uLsKLtdRBBfZEkH29A8ybSbItJkk02aSrDtPsu48ybpzuCv0ue1J3jpPN5JMm0kybYZsEmmQTSKN4srTjeJyHUVx5elGkT398ZNIL+oh02bIJpEG2STSIJtEGmSTSKO58nSjufJ0o7nydKO58nQD7gq9qocrTzeaK083mitPN5orTzeaK083hitPN+bWebox9wZhyFyhQeYKjSEjW4ZMPRmuPN0YrjzdGC6yJclcoUnmCk0yV2iSuULzcLJ6uNSTPLjUkzxubSPK49YgTB5c2nkKF9mSwkW2pHCRLSlceboJ95xedDPCRbakkD39hUs7T+HSzlO4tPNUsu5cybpzJevO9dY2ooSbSJ9cPpc2k8qlzaRykS2pXGRLKleebhqX6yiNi2xJI3v6G5k2A3eFXtVDps0YWXduZN25kXXndmsbUfqt83TTybQZJ9NmyCaRJtkk0nSuPN10LtdROleebjrZ09/JtBmySaRJNok0ySaRJtkk0iSbRJrBlaebwZWnm8GVp5vBlaebwZWnm8mVp5vJlaebyZWnm8mVp5twV+hVPVx5upm3ztPNvDcIQ+YKTTJXaBYZ2VJk6klx5elmceXpJt4VelEPmXZO5gpNMldokrlCk8wVmk2mnjSZetK3thFl3xuEgXtOL97WTUa2NBnZ0mRkS3Pl6WaTuY6GjGwZsqf/kGnnQ6adw12hV/WQdedD1p0PWXc+97YRza1BmDq4tJk6uLSZOrjIljq4yJY6nKq7qoPLdVQHF9lSB9fTvw4ubaYOLm2mhEubKeHqzku4uvMSru684K7Q57Yncus83RIubaaES5spskmkRTaJtJQrT7eUy3VUypWnW0r29MdPIr2oh0ubKbJJpEU2ibTIJpEW2STSMq483TKuPN0yrjzdMq483YK7Qq/q4crTLePK0y3jytMt48rTLePK0y3nytMtv3WebvmtQZgic4UWmSu0nItsKSdTT5wrT7ecK0+3nItsKTJXaJG5QovMFVpkrtAic4VWkKknQaaexK1tRBW3BmEqyLTzJCNbkoxsSTKyJbnydAvuOb3oZpKMbEmyp3+SaedJpp0nmXZeZN15kXXnRdad161tRAU3kT65fDJtpsi0mSIjW4qMbCmuPN1qLtdRNRnZ0mRP/ybTZuCu0Kt6yLSZJuvOm6w7b7LuvO9tI5pb5+nWkGkzQ6bNkE0iLbJJpDVcebo1ZK6j4crTrSF7+g+XNtNkk0ibbBJpk00ibbJJpH1wded9cOXp9sGVp9sHV55uH1x5un1w5em2cOXptnDl6bZw5em2cOXpNtwVelUPV55uy63zdFtuDcI0mSu0yVyhrVxkSyuXetLKlafbypWn23hX6EU9XNp5k7lCm8wV2mSu0CZzhbaRqSdGpp7YrW1EbbcGYRruOb14WxsX2dLGRba0cZEtbVx5um1crqN2LrKlnezp72TauZNp53BX6FU9ZN25k3XnTtad+61tRO23BmE6yLSZINNmgots6eAiWxrvOf24uwou11EHF9nSQfb0DzJtJsi0mSTTZpKsO0+y7jzJunO4K/S57UneOk+3k0ybSTJthmwSaZNNIu3iytPt4nIddXHl6XaRPf3xk0gv6iHTZsgmkTbZJNImm0TaZJNIu7nydLu58nS7ufJ0u7nydBvuCr2qhytPt5srT7ebK0+3mytPt5srT7eHK0+359Z5uj33BmHIXKFN5grtISNbhkw9Ga483R6uPN0eLrJlyFyhQ+YKHTJX6JC5Qudwsnq41JM5uNSTOW5tI5rj1iDMHFza+QgX2TLCRbaMcJEtI1x5ugP3nF50M8JFtoyQPf2FSzsf4dLOR7i081Gy7lzJunMl68711jaigZtIn1w+lzYzyqXNjHKRLaNcZMsoV57uGJfraIyLbBkje/obmTYDd4Ve1UOmzRhZd25k3bmRded2axvR+K3zdMfJtBkn02bIJpEO2STSca483XEu19E4V57uONnT38m0GbJJpEM2iXTIJpEO2STSIZtEOsGVpzvBlac7wZWnO8GVpzvBlac7yZWnO8mVpzvJlac7yZWnO3BX6FU9XHm6k7fO0528NwhD5godMlfoFBnZUmTqSXHl6U5x5ekO3hV6UQ+Zdk7mCh0yV+iQuUKHzBU6TaaeNJl60re2EU3fG4SBe04v3tZNRrY0GdnSZGRLc+XpTpO5joaMbBmyp/+QaedDpp3DXaFX9ZB150PWnQ9Zdz73thHNnUGYOA4qbeash0qbOeuhIlvOeqjIlrMeZ+quznqoXEdnPVRky1kP1dP/rIdKmznrodJm4hAqbeash6o7P+uh6s7Peqi687Mev3V7InfO0z3Lp9JmznqotJmzHqpfTs96qH45jUOp8nTPeqhcR2c9VHm6Zz1kT3/8JNKLeqi0mbMeKm3mrIesO+eaRHrWQ9adG1We7lkPVZ7uWQ9Vnu5Zz8/M033gPs96nKwesufzE1yhpse3Ht3UHlv0Jxg9L7fo/VvM9i2eYJk0jXjboh/byyfYGi+30P1b2P4tfP8WsX+L3L9F7d+i928x27d4hoMu5NuXo3OzxwfIM0xxV1vo/i1s/xa+f4vYv0Xu36L2b9H7t5jtW+T+0537T3fuP925/3Tn/tOd+0937j/duf90P8O5EyVvW8w7W8z2LZ7hr7naQvZvQeWCOeu5MzZ9lu/3Lp+Ksj7rIfslr8h+ySuyX/KKKj8wjqairM96yH7Ju7XH5iz/3i8LLo/NWQ/Z05/LY3PWQ/b05/LYnPVQeWzi4PLYnPWQUXxcHpuzHjKOg8tjc9ZD9jvh3Dn/5Cz/zvknZ/lkvf9wUXxC5rERMo+NHFzKjxxU+SdnPU5WD9fTX7jmup31cFF8QuaxETKPjZB5bITMYyPyMym+R0pNhIviE7jH5qqeIKvn1t25yK27cyHz2AiZx0aUrDtXsu5cybpzJevO8R6bi3rIunMyj42QeWyEzGMjZB4bMbLu3Mi6c7v1L6dit/7lVOAOnou3tXH9cirG9cupGNcvp2Jcv5yKcf1yKs71y6k42dPfuX45Fef65VTgk9eu6iHrzp2sO3ey7tzvnE54ln/rdEIJMm0myLSZ4EonlOBKJxT8XLePu6vgSieU4EonlCB7+geZNhNk2kySaTNJ1p0nWXeeZN05fK7bc9uTvHU6oSSZNpNk2gzXXLezHrJfTosrnVCKy9MkxZVOKEX29MfPdbuoh0yb4ZrrdtZD1p1zzXU76yHrzpsrnVCaK51QmiudUNrI6nGyeoKsniSrp8jqabJ6hqueIXs+D9nzeciez0P2fB6y5/OQPZ+H7Pk8ZM/n+ZnP53d8AjNU9Sjct/lUeU/hNs8nl8/126aSTV7Tw8nq4SIPFe8K/VCdVLwr9EM1UPGu0It6uNQTJXOFKpkrVMkmrynZ5DWFu0Kv6uFSt/XerlC9tytUyVyhSuYKVTJXqJK5QpXMFapkrlAlc4UqmStUyVyhSuYKVTJXqJK5QpXMFapkrlC9tytU7+0KVTJXqJK5QpXMFapkrlAlc4UqmStUyVyhSuYKVTJXqJK5QpXMFapkrlAlc4UqmStU7+0K1Xu7QpXMFapkrlAlc4UqmStUyVyhSuYKVTJXqJK5QpXMFapkrlAlc4UqmStUyVyhSuYKVbgr9GNOTpOLa9Tk4ho1ubhGTS6uUZOMa4T7Nj3e+jGPx/MO921e1aNk9RhZPX7rr491a9e+kk0iVbJJpEo2iVSLjGxpLte+kk0i1eZy7WuTdedwV+hVPWTaeZNp502mnjSZetJk6snc23U093YdDZl2PmTaOdxzelUPGdkyZK6jIXMdDZnraLie/nZwaed2cGnndnBp53Zwded2cHXnRjYr1I5bu47suLXryA4ubcYOLm3GhItsMeEiW0y4XEcmXK4jw3tOL+ohe/oLlzZjwqXNmHBpMyZk3bmSdedK1p3rrV1Hprd2HRncc3rxtlYubcaU65dTU65fTk25XEemXK4jMy7XkZF5Ts3ItBkj02bgrtCresi6cyPrzo2sOzeuPF0zrjxdc648XXOuPF1zrjxd85+Zp/vIxRrcFXpVD5w7/5D7NLgr9KqeIqunyeq5tc3T4tYgjJG5Qo3MFWpkrlCDu0Kv6gmub+NkrlALLrLFyFyhRuYKNTJXqJG5Qo3MFWpkrlCDu0Kv6rm1jcjy3iAM2axQI5sVamSzQq3IyBb8rNCPuyuyWaFWZGQL2axQI5sVamSzQo1sVqiRzQo1slmh1mTded/aRmR9bxCmybQZuOf0qh4ysqXJyBa85/Tj7qq5XEfWZGTLkD39h0ybGTJtZsi0Gbgr9Koesu58yLrzubeNaG4dv2vDpc34waXN+MH1y6mTTSJ1vOf0w+7KD6fqZvzgytP1g+vp7weXNuMHlzbjZJNInWwSqZNNInWySaQuP5NrfOQsHe4KvaqHK0/XhStP14UrT9eFK0/XhStP15UrT9eVK0/XlStP15UrT9fhvs2nfp11vTUI42SuUCdzhbpykS2uZOqJceXpunHl6bpxkS1O5gp1Mleok7lCncwV6mSuUDcy9cTI1BO/tY3I/dYgjDuZdu5cZIvDPadX9XCRLe5cebruXK4jdy6yxZ3s6R9k2nmQaedBpp0HWXeOnxV6UQ9Zdx63thF53BqE8SDTZoJMm0kysiXJyJbkytP15HIdOd5zelEP2dM/ybSZJNNmkkybSbLuvMi68yLrzuvWNiKvW+fpOtxzevG2LjJthmwSqZNNIvXiytP14nIdeXPl6XqTPf2bTJshm0TqZJNInWwSqZNNInWySaTeXHm63lx5uj5cebo+XHm6Plx5uj5ceboOd4Ve1cOVp+vDlafrw5Wn68OVp+tz6zzdOG4NwgSZKzTIXKFxcJEtcThZPVx5unFw5enGwUW2BJkrNMhcoUHmCg0yV2iQuUJDuNSTwM8Kvajn1jaikFuDMCFc2nkIF9kSwkW2hHKRLaFcebqhXK6jUC6yJZTs6a9c2nkol3YeyqWdh5J150rWnRtZd263thGF3RqECSPTZuCe06t6uMiWMC6yJYwrTzeMy3UUxkW2hJM9/Z1Mm3EybcbJtBm4K/SqHrLu3Mm6c7+1jSj81nm64WTaTJBpM2STSINsEmkEV55u4D2nH3czwZWnG0H29A8ybYZsEmmQTSINskmkQTaJNMgmkUZy5ekG3BV6VQ9Xnm4kV55uJFeebiRXnm4kV55uFFeebhRXnm4UV55uFFeebsB9m8/9Olv3BmHIXKFB5gqNIiNbikw9aa483WiuPN1oMrKFzBUaZK7QIHOFBpkrNMhcodFk6kmTqSdzbxvR3BuEGTLtfMjIFrjn9KoeMrJluPJ0Y8hcR0NGtgzX0z8PLu08Dy7tPA8u7TwPru48D67uPA+u7jyPW9uI8rg1CJMHlzaTB5c2k8JFtqRwkS0pXHm6KVyuo8R7Ti/qIXv6C5c2k8KlzaRwaTMpZN25knXnStad661tRKm3ztNNuOf04m2tXNpMkk0iTbJJpKlcebqpXK6jNK483TSyp7+RaTNkk0iTbBJpkk0iTbJJpEk2iTSNK083jStPN50rTzedK083nStPN50rTzfhrtCrerjydNO58nTTufJ007nydNNvnaebcWsQJslcoUnmCs3gIlsS7gq9qocrTzeDK083g4tsSTJXaJK5QpPMFZpkrtAkc4Vmkqkn+FmhF/Xc2kaUeW8QJsm08yQjW5KMbCkysqW48nSzuFxHWWRkS5E9/YtMOy8y7bzItPMi686LrDtvsu68b20jyr43CNNk2gzcc3pVDxnZ0mRkS3Pl6WZzuY6yyciWIXv6D5k2M2TazJBpM3BX6FU9ZN35kHXnc28b0dw6TzeHS5upg0ubKbJJpEU2ibQOrjzdOpyqm6mDK0+3Dq6nfx1c2kyRTSItskmkRTaJtMgmkRbZJNISrjzdgrtCr+rhytMt4crTLeHK0y3hytMt4crTLeXK0y3lytMt5crTLeXK0y24b/OpX2dLbw3CFJkrtMhcoaVcZEspmXpiXHm6ZVx5umVcZEuRuUKLzBVaZK7QInOFFpkrtIxMPTEy9cRvbSMqvzUIU06mnTsX2VJwz+lVPVxkSzlXnm45l+uonItsKSd7+geZdh5k2nmQaedB1p3jZ4Ve1EPWncetbUQVtwZhKsi0mSDTZpKMbEkysiW58nQruVxHhfecXtRD9vRPMm0mybSZJNNmkqw7L7LuvMi687q1jajq1nm6BfecXryti0ybIZtEWmSTSKu48nSruFxH1Vx5utVkT/8m02bIJpEW2STSIptEWmSTSItsEmk1V55uNVeebg1Xnm4NV55uDVeebg1Xnm7BXaFX9XDl6dZw5enWcOXp1nDl6dbcOk+3j1uDME3mCm0yV2gfXGRLH05WD1eebh9cebp9cJEtTeYKbTJXaJO5QpvMFdpkrtAWLvWk8bNCL+q5tY2o5dYgTAuXdt7CRba0cJEtrVxkSytXnm4rl+uolYtsaSV7+iuXdt7KpZ23cmnnrWTduZJ150bWndutbURttwZh2si0Gbjn9KoeLrKljYtsaePK023jch21cZEt7WRPfyfTZpxMm3EybQbuCr2qh6w7d7Lu3G9tI2q/dZ5uO5k2E2TaDNkk0iabRNrBlafbeM/px91McOXpdpA9/YNMmyGbRNpkk0ibbBJpk00ibbJJpJ1ceboNd4Ve1cOVp9vJlafbyZWn28mVp9vJlafbxZWn28WVp9vFlafbxZWn23Df5nO/zta9QRgyV2iTuUK7yMiWIlNPmitPt5srT7ebjGwhc4U2mSu0yVyhTeYKbTJXaDeZetJk6snc20Y09wZhhkw7HzKyBe45vaqHjGwZrjzdHjLX0ZCRLcP19J+DSzufg0s7n4NLO5+Dqzufg6s7n4OrO5/j1jaiOW4NwszBpc3MwaXNjHCRLSNcZMsIV57uCJfraPCe04t6yJ7+wqXNjHBpMyNc2swIWXeuZN25knXnemsb0eit83QH7jm9eFsrlzYzZJNIh2wS6ShXnu4ol+tojCtPd4zs6W9k2gzZJNIhm0Q6ZJNIh2wS6ZBNIh3jytMd48rTHefK0x3nytMd58rTHefK0x24K/SqHq483XGuPN1xrjzdca483fFb5+lO3BqEGTJX6JC5Qie4yJaBu0Kv6uHK053gytOd4CJbhswVOmSu0CFzhQ6ZK3TIXKGTZOoJflboRT23thFN3huESTLtPMnIliQjW4qMbCmuPN0pLtfRFBnZUmRP/yLTzotMOy8y7bzIuvMi686brDvvW9uIpu8NwjSZNgP3nF7VQ0a2NBnZ0lx5utNcrqNpMrJlyJ7+Q6bNDJk2M2TaDNwVelUPWXc+ZN353NtGNLfO052h0mbyOKi0mbMeql9Oz3qofjk966HK0z3rcaZu5qyHKk/3rIfq6X/WQ6XNnPVQaTNnPVTaTB5ck0jPeqi687Mequ78rIcqT/esx8nqocrTPeuhytM966HK0z3rocrTPeuhytPNQ6nydM96qPJ0z3qo8nTPeqjydM96/MZfZ8/y7wzCnOVTaednPVRky1kPFdly1kOmnhhVnu5ZD1We7lkPFdly1kOlnZ/1OFk9VNr5WQ+ZesLlCj3rIVNPjEw98TvbiM7y7wzCnOWTaedORbac9ThZPVRky1kPVZ7uWQ+V6+ish4psOeshe/oHmXYeZNp5kGnnQdad42eFXtRD1p3HnW1EZ/l3BmHO8sm0mSDTZpKMbEkysiWp8nTPeqhcR2c9TlYP2dM/ybSZJNNmkkybSbLuvMi68yLrzuvONqKz/Dvn6Z7lO9fbusi0Ga5JpGc9ZL+cFlWe7lkPlesoj6bK0z3rIXv6N5k2wzWJ9KzHyeoh6865JpGe9ZB1502Vp3vWQ5Wnm8dQ5eme9VDl6Z71UOXpnvVQ5eme9ThZPVR5umc9VHm6Zz1UebpnPVR5umc9d87TTTluDcIImStUyFyhcnCRLXI4WT1UebpnPVR5umc9XGSLkLlChcwVKmSuUCFzhQqZK1SESz0R/KzQi3pubSMSuTUII8KlnYtwkS0iXGSLKBfZIkqVp3vWw+U6EuUiW0TJnv7KpZ2LcmnnolzauShZd65k3bmRded2axuR2K1BGDEybQbuOb2qh4tsEeMiW8So8nTPerhcR2JcZIs42dPfybQZJ9NmnEybgbtCr+oh686drDv3W9uIxO+cp3uWT6bNBJk2wzWJ9KyH7JfT4MrTFbzn9ONuJrjydCXInv5Bps1wTSI96yHTZrgmkZ71kHXnXJNIz3q48nQF7gq9qocrT1eSK09XkitPV5IrT1eSK09XiitPV4orT1eKK09XiitPV+C+zed+na17gzBkrlAhc4VKkZEtRaaeNFeerjRXnq40GdlC5goVMleokLlChcwVKmSuUGky9aTJ1JO5t41o7g3CDJl2PmRkC9xzelUPGdkyXHm6MmSuoyEjW4br6a8Hl3auB5d2rgeXdq4HV3euB1d3rgdXd67HrW1EetwahNGDS5vRg0ubUeEiW1S4yBYVrjxdFS7XkeI9pxf1kD39hUubUeHSZlS4tBkVsu5cybpzJevO9dY2ItVb5+kq3HN68bZWLm1GySaRKtkkUlWuPF1VLteRGleerhrZ09/ItBmySaRKNolUySaRKtkkUiWbRKrGlaerxpWnq86Vp6v+M/N0H7lPdSWrh+z5TOYK1Se4Qu2UOP/yh+183j9ukfu3qP1b9P4tZvsWT7A1Xm4hT9gi4m2Lfmzan2A+vNzC9m/h+7eI/Vvk/i1q/xa9f4vZvkUe+7fYf7pz/+l+hhst5NsX53Ozx8fgMwxmV1vE/i1y/xa1f4vev8Vs3+IZlqqrLWT/Frp/i/2nu/af7tp/umv/6a79p7v2n+7af7p7/+l+hgsmSt62mHe20P1b2P4tfP8WXJMMtO/NrPW9mbUmY9aajFkbMmZtyJi1IWPWhoxZgztKruq5tT1c594viyFjIobs6T9cT387uJ7+dnDNSbCDy01uB9fT3w740//D39yMzK9iBxcTYQcXE2FkU8zsuPUMS5Nbm8+NzK9iwuUmN+Fykxvcr3JVD5fyY8I1w9KEy01uZH4VI/OrGJlfxcj8KqZcxLIpFxFnZFPMTH9mEusjwWiaZPUUWT1cSaym9+7O7d7duZF150bWnZNNMTOyKWZmZN25kXXnRtadG1l3bmTdOdkUMyObYmZkU8yMzK9iZH4V81v/cmp+619Ozbl+OTXn+uXUyKaYGdkUMwuyX06D7JfTIPvlNMie/kH2yynZFDMjm2JmZFPMjGyKmZFNMbO8dbC25a2joSzJtBn4jLSreriyniy5sp4suSbMW3LlcFtyZT1ZkT39i0ybKTJtpsi0GfiMtKt6yLrzIuvO69YmJatbT5g3shlp1mTaTJP9ctpkv5w214R5w89I+7ibaa4J80Y2I83IZqQZ2Yw0I5uRZkPWnQ9Zdz5k3flwTZg3uOf0qh6uCfM2XBPmbbgmzNtwJbHacCWx+sGVxOqHkNWjZPVwPZ/94Ho++8H1fPaD6/nsB9fz2Q+u57MfZM9nIXs+C1dStgtXUrbLrQfTONzm+eTyuX7bdOH6bdOFizx04SIPHe8K/VCddOWaY+N4V+hFPVzqiZO5Qp3MFerK9dumK5e67cqlbrtyqdt+b1eo39sV6mSuUCdzhTqZK9TJXKFO5gp1Mleok7lCncwV6mSuUCdzhTqZK9TJXKFO5gp1Mleo39sV6vd2hTqZK9TJXKFO5gp1Mleok7lCncwV6mSuUCdzhTqZK9TJXKFO5gp1Mleok7lCncwV6vd2hfq9XaFO5gp1Mleok7lCncwV6mSuUCdzhTqZK9TJXKFO5gp1Mleok7lCncwV6mSuUCdzhXqRcY1FxjUWGdfYZFxjk3GNTcY1wn2bpz7yVk88nne4b/OqniCrJ8nqubVr3/vWrn0nm0TqZJNInWwSqQ8Z2TJcrn0nm0Tqw+Xa9yHrzodMOx8y7Xy4tPM4uNSTOLjUkzi41JM4bu06isPvXT6Xdh4Hl3YeBxfZEgcX2RIHl+sohMt1FMLlOgohe/oLl3YecBPpVT1c2nkIV3cewtWdB9ms0JBbu45Cb+06CuXSZkK5tJlQLrIl4J7Tq3q4XEehXK6jUC7XUZB5TkPJtBkj02aMTJsxsu7cyLpzuCv0qp5bu47Cbu06CiPTZoxMmzGuX07DuX45DedyHYVzuY7CuVxHQeY5DSfTZpxMm3EybcbJunMn686DrDsPrjzdCK483QiuPN2Au0Kv6uHK0434mXm6j1xsRJHVA+fOP+Q+A+4KvagH7gq9qkfI6rm1zTPy3iAMmSs0yFyhQeYKjSRTT/Cu0I+/jZO5QqPIyBYyV2iQuUKDzBUaZK7QIHOFBpkrNIpMPbn38M+oe4MwZLNCg2xWaJDNCo0mI1vws0I/7q7IZoVGk5EtZLNCg2xWaJDNCg2yWaFBNis0yGaFxpB153BX6HPbk7k3CDNk2syQaTNDRrYMF9mSeM/ph91VHlyuozy4yJY8uJ7+eThZPVzaTB5c2kweXN15HlzdeR5c3XnKrW1EKbeO303h0mZSuLSZhHtOr+rh+uU08Z7Tj7sr4XIdpXDl6aaQPf2VS5tJ5dJmkmwSaZJNIk2ySaRJNok09WdyjY+cZSpXnm4qV55uKleebhpXnm4aV55uGleebhpXnm7CXaFX9XDl6aZx5emm3TpPN+3WIEySuUKTzBWazkW2pJOpJ86Vp5t4V+jH336di2xJMldokrlCk8wVmmSu0CRzhWaQqSdBpp7ErW1ECTeRPrl8Mu08uMiWDC6yJYOLbMngytPN5HIdZZKRLUn29E8y7RzuCr2qh0w7T7LuPMm68yTrzvPWNqKse4MwRabNFJk2U2RkC9xzelUPV55uFpfrKIuMbCmyp3+RaTNNps00mTbTZN15k3XneFfoRT23thFl3zpPN5tMm2kybYZsEmmSTSLN4crTzSFzHQ1Xnm4O2dN/yLQZskmkSTaJNMkmkSbZJNIim0RaB1eebh1cebp1cOXp1uFk9XDl6dbBladbB1eebh1cebp1cOXplnDl6ZZw5emW3DpPt+TWIEyRuUKLzBVawkW2lHCpJyVcebolXHm6pVxkS5G5QovMFVpkrtAic4UWmSu0lEs9KeVST0pvbSMqvTUIU8alnZdxkS1lXGRLGRfZUvhJpB93V8blOirjIlvKyJ7+xqWdl5Fp506mnTtZd+5k3bmTdedwV+hz2xO/NQhTTqbNOJk241xkSzkX2VLBladbweU6quAiWyrInv5wE+lVPWTaTJBpM0HWnQdZdx5k3Xne2kZUees83UoybSbJtBmySaRFNom0kitPt5LLdVTJladbSfb0LzJthmwSaZFNIi2ySaRFNom0yCaRVnHl6VZx5elWceXpVnHl6VZz5elWc+XpVnPl6VZz5ekW3BV6VQ9Xnm41V55u9a3zdKvvDcKQuUKLzBVaQ0a2DJl6Mlx5uoV3hX787XfIyBYyV2iRuUKLzBVaZK7QJnOF9sGlnvTBpZ70cWsbUR9+7/K5tPM+uMiWPrjIlj64yJY+uPJ0W7hcRy1cZEsL2dNfuLTzhrtCr+rh0s5buLrzFq7uvIWrO2+5tY2o9dYgTCuXNtPKpc20cpEtDfecXtXDlafbyuU6auUiW1rJnv5Kps0YmTZjZNqMkXXnRtad412hF/Xc2kbUdus83TYybcbItBmySaRNNom0nStPt53LddTOlafbTvb0dzJthmwSaZNNIm2ySaRNNom0ySaRdnDl6XZw5el2cOXpNtwVelUPV55uB1eebgdXnm4HV55uB1eebidXnm4nV55u563zdDvvDcKQuUKbzBXaSUa2JJl6klx5up1cebpdZGQLmSu0yVyhTeYKbTJXaJO5QrvI1JMiU0/q1jairnuDME2mnTcZ2dJkZEuTkS34SaQfd1fN5TrqJiNbmuzp32TaeZNp50OmnQ9Zdz5k3fmQdedwV+hz25O5NwgzZNrMkGkzQ0a2DBfZMgdXnu4cXK6jObjIljm4nv5zOFk9XNrMHFzazBxc3fkcXN35HFzd+citbUQjt87THeHSZka4tJkhm0Q6ZJNIR7jydEe4XEcjXHm6I2RPf+XSZoZsEumQTSIdskmkQzaJdMgmkY5y5emOcuXpjnLl6Y5y5emOceXpjnHl6Y5x5emOceXpDtwVelUPV57uGFee7tit83THbg3CDJkrdMhcoeNcZMs4mXriXHm6g3eFfvzt17nIliFzhQ6ZK3TIXKFD5godMlfoBJl6EmTqSdzaRjRwE+mTyyfTzoOLbJngIlsmuMiWCa483Uku19EkGdmSZE//JNPO4a7Qq3rItPMk686TrDtPsu48b20jmro3CFNk2kyRaTNFRrbAPadX9XDl6U5xuY6myMiWInv6F5k202TaTJNpM03WnTdZd453hV7Uc2sb0fSt83SnybSZJtNmyCaRDtkk0hmuPN0ZMtfRcOXpzpA9/YdMmyGbRDpkk0iHbBLpcE0irYNrEulZD1We7lkPVZ7uWQ9Vnu5Zj5PVQ5Wne9ZDlad71kOVp3vWQ5Wne9ZDladbh1Dl6Z71UOXpnvXcOU/3LP/OIMxZvjN9uzvroSJbznqoyJazHir15KyHKk/3rIcqT7cOpSJbznqotPOzHirt/KyHSjs/63GyeqjUk7MeKvXkrIdKPTnrubON6Cz/ziBMHUalnZ/1UJEtZz1UZMtZDxXZctbjXN2VUbmOznqoyJazHrKnv1Fp52c9ZNq5k2nnTtadO1l37mTdOdwV+tz2xO8Mwpzlk2kzTqbNOBXZctZDRbbUEVR5umc9VK6jsx4qsuWsh+zpDzeRXtVDps0EmTYTZN15kHXnQdad551tRGf5d87TPcsn02aSTJvhmkR61kP2y2lS5eme9VC5js56qPJ0z3rInv5Fps1wTSI96yHTZrgmkZ71kHXnXJNIz3qo8nTPeqjydM96qPJ0z3qo8nTraKo83bMeqjzdsx6qPN2zHqo83bMeJ6uHKk/3rIcqT/es5855umf59wZhuFyhdXC5Qs96yMiWIVNPhipP96zHub79DhnZwuUKPesh0865XKFnPVzqiZC5QuXgUk/k4FJP5Li1jUgOv3f5XNq5HFxkixxcZIscXGSLHFR5uiXC5ToS4SJbRMie/sKlnQvcFXpVD5d2LsLVnYtwdeciXN25yK1tRKK3BmFEubQZUS5tRpSLbBG45/SqHqo83bMeLteRKBfZIkr29FcybcbItBkj02aMrDs3su4c7wq9qOfWNiKxO+fpnuWTaTNGps1wTSIt4ZpEetZDlad71sPlOhKnytM96yF7+juZNsM1ifSsh0yb4ZpEetZD1p1zTSI96+HK05XgytOV4MrTFbgr9KoerjxdCa48XQmuPF0JrjxdCa48XUmuPF1JrjxdyVvn6UreG4Qhc4UKmStUkoxsSTL1JLnydCW58nSlyMgWMleokLlChcwVKmSuUCFzhUqRqSdFpp7UrW1EUvcGYZpMO28ysqXJyJYmI1vwk0g/7q6ay3UkTUa2NNnTv8m08ybTzodMOx+y7nzIuvMh687hrtDntidzbxBmyLSZIdNmhoxsGS6yRQ+uPF09uFxHenCRLXpwPf31cLJ6uLQZPbi0GT24unM9uLpzPbi6c5Vb24hUbp2nq8KlzahwaTNKNolUySaRqnDl6apwuY5UuPJ0Vcie/sqlzSjZJFIlm0SqZJNIlWwSqZJNIlXlytNV5crTVeXK01XlytNV48rTVePK01XjytNV48rTVbgr9KoerjxdNa48XbVb5+mq3RqEUTJXqJK5QtW5yBZ1MvXEufJ0Fe8K/fjbr3ORLUrmClUyV6iSuUKVzBWqZK5QDTL1JMjUk7i1jUjhJtInl0+mnQcX2aLBRbZocJEtGlx5uppcriNNMrIlyZ7+Saadw12hV/WQaedJ1p0nWXeeZN153tpGpHVvEKbItJki02aKjGyBe06v6uHK09Xich1pkZEtRfb0LzJtpsm0mSbTZpqsO2+y7hzvCr2o59Y2Iu1b5+lqk2kzTabNkE0iVbJJpDpcebo6ZK6j4crT1SF7+g+ZNkM2iVTJJpEq2SRSJZtEamSTSO3gytO1gytP1w6uPF07nKwerjxdO7jydO3gytO1gytP1w6uPF0TrjxdE648XZNb5+ma3BqEMTJXqJG5Qk24yBYTLvXEhCtP14QrT9eUi2wxMleokblCjcwVamSuUCNzhZpyqSemXOqJ6a1tRKa3BmHMuLRzMy6yxYyLbDHjIlsMP4n04+7KuFxHZlxkixnZ09+4tHMzMu3cybRzJ+vOnaw7d7LuHO4KfW574rcGYczJtBkn02aci2wx5yJbLLjydC24XEcWXGSLBdnTH24ivaqHTJsJMm0myLrzIOvOg6w7z1vbiCxvnadrSabNJJk2QzaJ1MgmkVpy5elacrmOLLnydC3Jnv5Fps2QTSI1skmkRjaJ1MgmkRrZJFIrrjxdK648XSuuPF0rrjxda648XWuuPF1rrjxda648XYO7Qq/q4crTtebK07W+dZ6u9b1BGDJXqJG5Qm3IyJYhU0+GK0/X8K7Qj7/9DhnZQuYKNTJXqJG5Qo3MFepkrlA/uNQTP7jUEz9ubSPyw+9dPpd27gcX2eIHF9niBxfZ4gdXnq4Ll+vIhYtscSF7+guXdu5wV+hVPVzauQtXd+7C1Z27cHXnLre2EbneGoRx5dJmXLm0GVcussXhntOrerjydF25XEeuXGSLK9nTX8m0GSPTZoxMmzGy7tzIunO8K/SinlvbiNxunafrRqbNGJk2QzaJ1Mkmkbpz5em6c7mO3LnydN3Jnv5Ops2QTSJ1skmkTjaJ1MkmkTrZJFIPrjxdD648XQ+uPF2Hu0I/5j49gqwesuczmSvUn+AKNT2+fWcwtcevDE8wel5t8QTv5uUWsn8L3b+F7d/Cn7BFxNsW/di0P8F8eLlF7t+i9m/R+7eY7VvUsX8L2b+F7t/C9m+x/3Q/w7oW8u1b7bnZ4zPqGW60qy1q/xa9f4vZvsUznF1XW8j+LXT/FrZ/C9+/xf7T3ftPd+8/3b3/dPf+0z37T/fsP92z/3Q/wzITJW9bzDtb+P4tYv8WuX8L+Jf0j3+kmFu7CX1uzcPFwfUTWhxcgFscXIBbHFyAWxxO9TSJg8t8GAcX4BbHra3ncdz6ZREHF0ARQvb0F7Knv5A9/YXLeh54c8vHTzche/qTmVuCzNwSZOaWEC6AIpQLoAi9dQ5r6K3nYwaZuSXIzC2hXNbzUC7reSiX8hPKFdsayjXwMsjMLUFmbgkyc0uQmVuCzNwSxoU3h5F158Y1jj6syeoZrnr8IKvn3t2537s7d7LuHG5uuaqHrDsnG3kWTtadO1l37mTdOZm5JYKsOw+y7pxs5FmQjTwLspFnQWZuibj3L6dx719Og+yX0yT75TTJfjklG3kWSfbLKXzk2UU3k2S/nCbZ0z/JfjlNsl9OyUaeBdnIsyAbeRZkI8+ibh3aHfAJaU8un0ybKTJtpriCoaK4gqGiuEK7o7lCu6O5QrujyZ7+TabNwAeqXdVDps00WXfeZN15k3XnfW+T0tw6tDvIBqoF2UC1GLJfTuED1a7q4QrtjiHzNA1XaHeQDVQLsoFqSTZQLckGqiXZQLU8uLrzPLi68zx+ZizgY2xiHlzj6PPgGkefB9c4+jy4xtGncI2jT+GKbU3him1N4YptTbgr9KoesuezkD2fhez5LGTPZyF7PivZ81nJns9K9nzWn/l8fvQJpDpZPbceepN666E3qVy/baZy/baZykUepnGRh2lcQ2/SuIbepHENvUkyV2iSuUKTzBWaxvXbZhqXup1Gpm47mbp9b1do3tsVmmSu0CRzhSaZKzTJXKFJ5gpNMldokrlCk8wVmmSu0CRzhSaZKzTJXKFJ5gpNMldo3tsVmvd2hSaZKzTJXKFJ5gpNMldokrlCk8wVmmSu0CRzhSaZKzTJXKFJ5gpNMldokrlCk8wVmvd2hea9XaFJ5gpNMldokrlCk8wVmmSu0CRzhSaZKzTJXKFJ5gpNMldokrlCk8wVmmSu0CRzhWaTcY1DxjUOGdc4ZFzjkHGNcN/mVT1w7jze+jGPx/MO921e1VNk9TRZPbd27ddxa9d+kU0iLbJJpEU2ibQOJ6uHy7VfZJNI6+By7dfB1Z3XwaWdl3Bp5yVc2nkJl3pSwqWeFH5W6EU9t3YdldzadVTCpZ2XcGnnJVxkSykX2VLK5Toq5XIdlXK5jkrJnv7KpZ2XcmnnpVzaeSlZd65k3TnZrNCyW7uOym7tOioj02bgntOrerjIljIusqWMy3VUxuU6KuNyHRWZ57ScTJtxMm3GybQZuCv0qh6y7tzJunO/teuo/Nauo3IybSbItJkg++U0yH45DS7XUeE9px93M8HlOioyz2kFmTYTZNpMkGkzSdadJ1l3nmTdeXLl6RbcFXpVD1eebiVXnm4lV55u5c/M033kYiuHqx64K/Rj7rPgrtCrepSsHiOrx2/9dbbuDcKQuUKLzBVaZK7QKjL1BO8K/fjbOJkrtJqMbCFzhRaZK7TIXKFF5gotMldokblCq8nUk3sP/6y5NwhDNiu0yGaFFtms0BoysgU/K/Tj7opsVmgNGdlCNiu0yWaFNtms0CabFdpks0L74OrO++Dqzvu4tY2oj1uDMH1waTN9cGkzLVxkSwsX2dJ4z+mH3VULl+uo8Z7Ti3rInv7Cpc20cGkzLVzaTAtZd65k3bmSded6axtR663jdxvuOb14WyuXNtPK9ctpk00ibbzn9OPuSrlcR21cebptZE9/I9NmjEybIZtE2mSTSJtsEmmTTSJt+5lco7zz/OHK023nytNt58rTbefK023nytNtuCv0qh6uPN12rjzddq483XauPN32W+fpdtwahGkyV2iTuUI7uMiWhrtCr+rhytPt4MrT7eAiW5rMFdpkrtAmc4U2mSu0yVyhnWTqCX5W6EU9t7YRdd4bhEky7TzJyJYkI1uKjGwprjzdLi7XURcZ2VJkT/8i086LTDsvMu28yLrzIuvOm6w771vbiLrvDcI0mTYD95xe1UNGtjQZ2dJcebrdXK6jbjKyZcie/kOmzQyZNjNk2gzcFXpVD1l3PmTd+dzbRjS3ztPt4dJm5uDSZoZsEumQTSKdgytPdw6n6mbm4MrTnYPr6T8HlzYzZJNIh2wS6ZBNIh2ySaRDNol0hCtPd+Cu0Kt6uPJ0R7jydEe48nRHuPJ0R7jydEe58nRHufJ0R7nydEe58nQH7tt86tfZ0VuDMEPmCh0yV+goF9kySqaeGFee7hhXnu4YF9kyZK7QIXOFDpkrdMhcoUPmCh0jU0+MTD3xW9uIxm8NwoyTaefORbYM3HN6VQ8X2TLOlac7zuU6GuciW8bJnv5Bpp0HmXYeZNp5kHXn+FmhF/WQdedxaxvRxK1BmAkybSbItJkkI1uSjGxJrjzdSS7X0eA9pxf1kD39k0ybSTJtJsm0mSTrzousOy+y7rxubSOaunWe7sA9pxdv6yLTZsgmkQ7ZJNIprjzdKS7X0TRXnu402dO/ybQZskmkQzaJdMgmkQ7ZJNIhm0Q6zZWnO82VpzvDlac7w5WnO8OVpzvDlac7cFfoVT1cebozXHm6M1x5ujNcebozd87T7eO4Mwhzlk+lnZ/1UJEtZz1UZMtZj5PVQ5Wne9ZDlad71kNFtpz1UGnnZz1U2nkfXK7Qsx4q9eSsh0o9OeuhUk/OepysnjvbiM7y7wzCnOVTaednPVRky1kPFdnSh1KRLWc9VHm6Zz1UrqOzHiqy5ayH7OmvVNr5WQ+Vdn7WQ6Wdn/WQdedK1p0bWXdud7YRneXfGYQ5yyfTZuCe06t6qMiWsx4qsuWshypP96yHynV01kNFtvThZE9/J9NmnEybcTJtBu4KvaqHrDt3su7c72wjOsu/c57uWT6ZNhNk2gzXJNKzHrJfToMqT/esx7m6maDK0z3rIXv6B5k2wzWJ9KyHTJvhmkR61kPWnXNNIj3rocrTPetxsnqo8nTPeqjydM96qPJ0z3qo8nTPeqjydPsoqjzdsx6qPN2zHqo83bMeqjzdsx6/9dfZujcIw+UKPeshI1uKjGwpMvWkqfJ0z3qo8nTPesjIFi5X6FmPk9VDpp1zuULPesjUkyZTT5pMPZl724jm3iDMkGnnQ0a2wD2nV/WQkS1Dlad71kPmOhoysmW4nv5ycGnncnBp53JwaedycHXncnB153Jwdedy3NpGJMetQRg5uLQZObi0GREuskWEi2wRocrTPevhch0J3nN6UQ/Z01+4tBkRLm1GhEubESHrzpWsO1ey7lxvbSMSvXOe7lm+c72tlUubEa5JpGc9XL+cilLl6Z71cLmOxKjydM96yJ7+RqbNcE0iPetxsnrIunOuSaRnPWTduVHl6Z71UOXptjhVnu5ZD1We7lkPVZ7uWQ9Vnu5Zj5PVQ5Wne9ZDlad71kOVp3vWQ5Wne9Zz6zxdiVuDMELmChUyV6gEF9kicFfoVT1ceboSXHm6Elxki5C5QoXMFSpkrlAhc4UKmStUkkw9wc8Kvajn1jYiyXuDMEmmnScZ2ZJkZEuRkS3FlacrxeU6kiIjW4rs6V9k2nmRaedFpp0XWXdeZN15k3XnfWsbkfS9QZgm02bgntOresjIliYjW5orT1eay3UkTUa2DNnTf8i0mSHTZoZMm4G7Qq/qIevOh6w7n3vbiObWeboyXNqMHlzajJJNIlWySaR6cOXp6uFU3YweXHm6enA9/fXg0maUbBKpkk0iVbJJpEo2iVTJJpGqcOXpKtwVelUPV56uCleergpXnq4KV56uCleeripXnq4qV56uKleeripXnq7CfZtP/TqremsQRslcoUrmClXlIltUydQT48rTVePK01XjIluUzBWqZK5QJXOFKpkrVMlcoWpk6omRqSd+axuR+q1BGHUy7dy5yBaFe06v6uEiW9S58nTVuVxH6lxkizrZ0z/ItPMg086DTDsPsu4cPyv0oh6y7jxubSPSuDUIo0GmzQSZNpNkZEuSkS3JlaeryeU6Urzn9KIesqd/kmkzSabNJJk2k2TdeZF150XWndetbURat87TVbjn9OJtXWTaDNkkUiWbRKrFlaerxeU60ubK09Ume/o3mTZDNolUySaRKtkkUiWbRKpkk0i1ufJ0tbnydHW48nR1uPJ0dbjydHW48nQV7gq9qocrT1eHK09XhytPV4crT1fn1nm6dtwahDEyV6iRuULt4CJb7HCyerjydO3gytO1g4tsMTJXqJG5Qo3MFWpkrlAjc4WacKknhp8VelHPrW1EJrcGYUy4tHMTLrLFhItsMeUiW0y58nRNuVxHplxkiynZ01+5tHNTLu3clEs7NyXrzpWsOzey7txubSMyuzUIY0amzcA9p1f1cJEtZlxkixlXnq4Zl+vIjItsMSd7+juZNuNk2oyTaTNwV+hVPWTduZN1535rG5H5rfN0zcm0mSDTZsgmkRrZJFILrjxdw3tOP+5mgitP14Ls6R9k2gzZJFIjm0RqZJNIjWwSqZFNIrXkytM1uCv0qh6uPF1LrjxdS648XUuuPF1LrjxdK648XSuuPF0rrjxdK648XYP7Np/7dbbuDcKQuUKNzBVqRUa2FJl60lx5utZcebrWZGQLmSvUyFyhRuYKNTJXqJG5Qq3J1JMmU0/m3jaiuTcIM2Ta+ZCRLXDP6VU9ZGTLcOXp2pC5joaMbBmup78fXNq5H1zauR9c2rkfXN25H1zduR9c3bkft7YR+XFrEMYPLm3GDy5txoWLbHHhIltcuPJ0XbhcR473nF7UQ/b0Fy5txoVLm3Hh0mZcyLpzJevOlaw711vbiFxvnafrcM/pxdtaubQZJ5tE6mSTSF258nRduVxHblx5um5kT38j02bIJpE62SRSJ5tE6mSTSJ1sEqkbV56uG1eerjtXnq47V56uO1eerjtXnq7DXaFX9XDl6bpz5em6c+XpunPl6brfOk/X49YgjJO5Qp3MFerBRbY43BV6VQ9Xnq4HV56uBxfZ4mSuUCdzhTqZK9TJXKFO5gr1JFNP8LNCL+q5tY3I894gTJJp50lGtiQZ2VJkZEtx5el6cbmOvMjIliJ7+heZdl5k2nmRaedF1p0XWXfeZN1539pG5H1vEKbJtBm45/SqHjKypcnIlubK0/Xmch15k5EtQ/b0HzJtZsi0mSHTZuCu0Kt6yLrzIevO5942orl1nq4PlzYTB5c2E2STSINsEmkcXHm6cThVNxMHV55uHFxP/zi4tJkgm0QaZJNIg2wSaZBNIg2ySaQhXHm6AXeFXtXDlacbwpWnG8KVpxvClacbwpWnG8qVpxvKlacbypWnG8qVpxtw3+ZTv86G3hqECTJXaJC5QkO5yJZQMvXEuPJ0w7jydMO4yJYgc4UGmSs0yFyhQeYKDTJXaBiZemJk6onf2kYUfmsQJpxMO3cusiXgntOrerjIlnCuPN1wLtdROBfZEk729A8y7TzItPMg086DrDvHzwq9qIesO49b24gibg3CRJBpM0GmzSQZ2ZJkZEty5elGcrmOAu85vaiH7OmfZNpMkmkzSabNJFl3XmTdeZF153VrG1HUrfN0A+45vXhbF5k2QzaJNMgmkUZx5elGcbmOornydKPJnv5Nps2QTSINskmkQTaJNMgmkQbZJNJorjzdaK483RiuPN0YrjzdGK483RiuPN2Au0Kv6uHK043hytON4crTjeHK0425dZ5uHrcGYZLMFZpkrtA8uMiWPJysHq483Ty48nTz4CJbkswVmmSu0CRzhSaZKzTJXKEpXOpJ4meFXtRzaxtRyq1BmBQu7TyFi2xJ4SJbUrnIllSuPN1ULtdRKhfZkkr29Fcu7TyVSztP5dLOU8m6cyXrzo2sO7db24jSbg3CpJFpM3DP6VU9XGRLGhfZksaVp5vG5TpK4yJb0sme/k6mzTiZNuNk2gzcFXpVD1l37mTdud/aRpR+6zzddDJtJsi0GbJJpEk2iTSDK0838Z7Tj7uZ4MrTzSB7+geZNkM2iTTJJpEm2STSJJtEmmSTSDO58nQT7gq9qocrTzfzZ+bpPnKfmUVWD9nzmcwVmk9whZoe374zmNrjV4YnGD0vt9D9W9j+LXz/FrF/i3zCFhFvW/Rj0/4E8+HlFr1/i9m+RR/7t5D9W+j+LWz/Fr5/i9i/xf7T/QTrmlt/+9Z//qM+btH7t/j7T7fn27vbW+PjF73IzJt0p4c+VvQEi9mzKxK6ipSuIgNXpIfH94ri8Xw+wWr2myuyX1XUH/9xr9S3/7b01X/btd7+2x6PguUTjGx3utp8qautl7ra/lRXK/nx1c4LXW0dx6e62l+9E0PeuVp5qavVl7pae6mr9U91tW+//f5ytXL1x6W/35xTVLr443HUt18qz39uebyXn6tT+7n38nP1gT/3Xn6uLnPrvTy/D7/dS7F3npefq4f9uffyc3XIP/Veyufqv/fey+/6Ukg+Pi/lc3X3P/defq7vDj/3Xn6ubyY/917617182r38+t7zvHv59b3neffy63vP334v+/t3SJl37uXX957n3cuv7z1Pu5f69b3neffy63vP33wv9Xj7PSxU7fFefn3ved69/Pre87x76V/38mn38ut7z/Pu5df3nufdy6/vPX/7vXT9fi/jnXv59b3neffy63vP0+6lfX3ved69/Pre87ffy+zv97Lj8V5+fe953r38+t7zvHvpX/fyaffy63vP8+7l1/ee593Lr+89z7uXX997nvZ93L6+9zztXvrX956/+V5e/T7uX997nncvf8L3ng9dsuVsvt16QtDpnT9v8v3zJn9vDGb5a/fgz72Xr92DP/devnYP/tx7+do9+G+6lyFvbIuHvvPuee0e/Kn3Ml67B3/uvXztHvy33cvvN8Wj5/FevvZvD8+9l6/928Nz76V/3cunPS+/vvc8rb+MZFMIougq+lQ9eJh+/7zVcfHHLfztMFpUPt6cT9VUP/nm5Kfqkn/jzcnj+81J0ceb86na3mffnE/Vxz775nyqxvTZN8df+YHc+qubY1fdkX3vvdze+QU8P1Wn+ZPv5adS2H/yvfxUCvvee+lq378BmT/ey5fu7p98L1/6y8Bz72W98neH33ov+/vz0ufxeVmv/FXj2ffylb+ZPPtevvIXmWffS/+6l3/rvQzP7wr7O4pnfX3ved69/Pre87x7+fW952n3sj/Xe7y+zyaI6cer/Vxv2qurxb8Ltb9frT9m0z5hKtjZAORbRfkofD5hKtjlFk94/kx/+7Uxjnfk22dMBbvaYrZv8YwxX1db/P3f6eJ4m1YTRzxCG08YxHW5he3fwvdvEfu3yP1b1P4tev8Ws3uLfsKgn8stZP8Wun8L27+F798i9m+R+7eo/Vv0/i32n27Zf7pl/+mW/adb9p9u2X+6Zf/pfkKgdejxtoXmO1vU/i16/xazfYsnhOVebiH7t9D9W9j+LXz/FrF/i/2nW/efbt1/unX/6bb9p9v2n27bf7pt/+l+QtxUmHyj/cP+M1/8jghXvwp0KdOLPIMZ/aavzHg/lh/3Lj/vXX7du/wmL3/eBPTjkHfO7ty7/idE5Pzc+uXm9St1/WfR33+vOQ575wLs7hfA/fb9Gy6A+/17Fv32k+X5z/XOBXC/gf+GC+B+B8shx9tPzIeIPV4A91v4b7gA7tfw9QUE93v4LDrq+wVkPV4A94v4b7gA9jfx5QWwv4kvL4D9Rab5Zqk/X8r+eAHsL7LLC2B/kf2nC3icStbB/iK7vAD2F9nVBST7i+zyAthfZJcXwP4iu7wA9hfZ5QX43S/gVm/i9y7gVm/i9y7g7m/ivPubOO/+Jq67v4nr7m/iuvubuO7+Jn6C1w95AY/fiYv9TWzf3emHvaNOF/ub+PIC2N/Ebm85P4f7Ox8h9jfx5QWwv4mvLqDZ38SXF8D+Jr68APY38eUFsL+J/Xslh8/xeAHsb+LLvwH2N/HlBbC/iS8v4O5v4qZ/E18d4ru/iefub+K5+5t47v4mnru/iZ9h8/25fwN3fxPP3d/Ec/c38dz9TTw3fxPPcfM38Rw3fxPPcfM38Rw3fxPPcfM38Rw3fxPPcfM38Rw3fxPPcfM38Rx3fxPL3d/Ecvc3sdz9TSx3fxM/Iz7j5/4N3P1NLHd/E8vd38Ry9zex3P1NrHd/E+vd38R69zex3v1N/Iyom5/7N3D3N7He/U2sd38T693fxHr3N7Hd/U1sd38T293fxHb3NzF5LNXf8Ddw9zcxeTTV33ABd38Tk8dT/Q2H+O5vYvKAqr/hAu7+JqaPqLq8gLu/iekjqi7/Bu7+JqaPqLq8gLu/iekjqi4PMfxNbPOWt1P+y3/wwz8u54Jvf1zk0Yo4+IiqZ1+AkF+AHfF2Aab5eAF69wuwu1+A3/0CgvwCvN7eAxLH1VNX57t/Wmeu/ush/nZ7QlIeb09+3Z6Pbk993Z6Pbk9/3Z6Pbg97B/Rzb0+y91c/+fawd28/+faw94Z7b48ebznroWqPt4e98/zJt8e/bs9Ht+e1u+bL2/PaXfPl7Xntrvny9rx21/wrmTG04/H2vHbXfHV76rW75svb89pd8+XtefGu+er2vHjXfHV7nP32yLzdHtd5vAD6vvbqAug7z6sLoO8Nry7gs3Vv+qtHhPvj9X62duzievuz9VdX1/vZGqar6/1sHdDRH1/vZ2tprq7XX+x6P5tUd3W9n017q/lVi/74O0d/NjHt6no/W391db2frb+6uN55bf3q+P5fj6PfuT2vrV9d3p7X1q8ub89r61fy/bt7iD0iyfgk2HvdnhdnJa9uz4uzkle358VZyf7+aJb3+p4XZyWvbs+Ls5If3p45jhdnJa9uz4v/6utv1xka9nh7XvxX36vb8+K/+l7dHv+6PR/dnhdnJT9kBs7b88VKvt0efefT88VKfnh7vhxGb31PvtP3fDmMPro9cm8H93kB7H3t5QV8rs7Tjnx7XtnRx+P1fq5W8vp6/cWu93M1e9fXy969hX/H9SIf209h768uL4C9A7q8APYe5eoClL2LsH6rRPy4+uPu36/X/b3rpY+NefL10qfMPPl66UNpnny9fmvk/LyAe7sWzgu4t2vhvIB7uxbOC3gp18J5vS/lWpjDXsq1cF7vS7kWzuv9bL/gXV3vZ/tJ7up6/ZUo/vN6X8q1cF7vZ/sV7Op6P9vPWlfX+1KuhfN6X8q1MId/tv7q6no/W391db1fvoK//PF3fAXn7XltQury9vjX7fno9nz5Cr7dnkdw/rw9X76CD2/Pi/sKrm7PixNSV7fny1fwdnve6XvoZ1z85Nvz4hnMV7fntbvmy9vz5Sv4dnveA+fpZ4v85Nvz4r6Cq9vz4r6Cq9vz4r6CC1fKi08uubJdvPjkkqvb8zW55Hvf847t4mtyyce3h71rvjJ10M8WubwAfy2K/5ON87i+3s/VG15f7+dq9q6vl757i19ZCiQfL4C+v7q4AP4pFFcXQN+jXF0AvfZ2dQH06tjVBfjNjU300xAuL+Du7kT6aQiXF8D+Jn6yl4h+GsKTr5d+GsKzr/fFvI/00xCefb30TceFkYt/vMHVBdzdzMg/gODqAj7bT0MX3ppPN1Hg6npfzPv46SYKXF3vi3kfP13m/9X1vtTEpvN6/cWu98W8j58uN//qel9qYtN5vS/mffx0UfUfX698uuz5q+v9GsH0lz/+nptLXjxM/vL2fFklP7w9/mVX+svteceuJC8eJn95e76skh/eni+r5Ie352sE09vtea/v+bJKfnR76MPkf/Lt+bJKfnh7vkYwfbs979iV5JPl5j/99vjX7fno9nxZJT+8PS9ulfzYCyj0IwJ+qtlN6AcQ/OTb8zWC6a3veTS7Cf3whJ98e24+4EnohydcXsBrTWwS/mkIT77e1/I+Cv+shSdfL3339rGNSPhHM1xdwM3NjMI/POHqAm5uZhT+8QZXF8DeRVwYuYR+AMHlBdzczCj0IwIuL4D9TfxcL5HQZ/4/+3pfy/so9Jn/z77e1/I+Cn/m/8dGLuFP5b+6AL/7BdzczCifLnv+Y2+NfLow+avrfS3vo3y6uPeL6/10+e0fe2vk0wWyX13vZ8OGrq73tbyP8uky0C+8NZ8u1Pzqej9bf3V1va/lfZQXzxG/cvu8eI741e158Rzxy9vz4kj5hZ2FPkf8J9+e10bKL2+Pf92ej27PixsxL+wsnyxh/em358WNmFe358uI+eHtefHpOxd2Fv7s+Z97e167a768PV9GzA9vz4sbMS+8YvSZ/z/XDEU/UeAn354X75ovzFD00xB+8u1h75qvrFb0wxOuLoB+GsKTvTX00xCefb2fqze8vt4X8z7yD0+4sJnwD0+4ugD6DujqAu5uN+SfhnB1AXe3G9LPK8jj+wWk6+MFsLcFlxfA/p7P8bcLKHl8kdGPCLi8APY38eUFsL+JLy+A/U1cv7IbVr5ziNnfxGXx8QWwv4kvP0Lsb+KLC1D6ZPvLC6B/E19dAPub+OIppPRx7xdPIT1u/iZW+sj0ywtgfxNfXgD7m/jyAtjfxJdPIfY38dVTiD5c++ojRB9/fXkBN/9OrPQR0pcXwP4mvnoK0ccwXz6F7v4mpo8yvryAm38nVvo44KsLoA/svXoK0UfqXj2F6CN1Lz9Cd38T02fkXl7A3b8T06fYXj6Fbq5OK30s7eVH6O5vYvpY2ssLuPt3YvpY2qunEH0s7dVTiD6W9vIjdPc3MX0s7eUF3P07MX3O7OVT6O7qNH0S7NVHiD7a9fIC7v6dmD6r9fIC2N/EV08h+qzWy6fQ3d/E9OGrlxdw9+/E9PGoVxdAn3d69RSiDzC9egrRJ5JefoTu/iamzwy9vIC7fyemT/W8fArdXZ2mz928/Ajd/U1Mn115eQF3/05Mn/949RSiT2i8egrRZyhefoTu/iamzyG8vIC7fyemz/K7fArdXZ2mz8O7+gjRJ9ZdXsDdvxPTp75dXgD7m/jqKUSfnHb5FIK/ifN7WlPVYY8VFV1F8Hdl2a8qqnf+1oatInzGVn1/tlRLPVYkdBXB3zf9q7+1jnis6BkvkP72iAyXq6ynFnm7Ry3x+EZ4StbTcysKuoqSrqKiq6jpKhq2ip6SaPTcioSuIkVXpP72zO6zQf74j+cc394HOb965fyyzcMfPv/T3y629Ve94PmH/3yt9kLX6i90rfFC15ovdK31QtfaL3St8zLXasfxQtcqL3Str9M32fE6fZMd/kLX+jp9kx2v0zfZ8Tp9kx2v0zfZ8UJ9k7xQ3yQv1DfJC/VN8kJ901NSwu5yrS/UN8kL9U3yQn2TvFDfJC/UN+kL9U36Qn2TvlDfpC/UNz0l0+0u1/pCfZO+UN+kL9Q36Qv1TfpCfZO9UN9kL9Q32Qv1TfZCfdNTEvjucq0v1DfZC/VN9kJ9k71Q32Qv1Df9IINw/G1C9vzaxvHetc53e9JxfPdw2PGXHd7vVma+7aDH0b/e4c+rdGmVLa3ypVWxtCqXVtXSql5aNSurfpCgdbVq6bMRS5+NWPpsxNJnI5Y+G7H02Yilz0YsfTZi6bORS5+NXPps5NJnI5c+G7n02cilz0YufTZy6bORS5+NXPps1NJno5Y+G7X02XjfxK6H2tsqe2eVv78q9G1V+uOqeH9V9bdV5yv2cdW7nw39bh1SMXtcVe+v8npbVe/s1UurZmXV+57dy1Xy/qp+uxt6PN75972vl6tsaZUvrXr/s3Eue1tl9bjq/c+Ghrytynhc9f5nQ2veVs07q97/bNjxtuqUmh9XzW9ddf7Lf//XP/zxj3/4X//tj//yj//w73/4l3/+t1+WHr/8nx8oRh82qT9QXi7W+MKaWFiTC2tqYU0vrJnfvub9bxwXa2RhzcLnwBc+B77wOfCFz4EvfA584XPgC58DX/gcxMLnIBY+B7HwOYiFz0EsfA5i4XMQC5+DWPgcxMLnIBY+B7nwOciFz0EufA5y4XOQC5+DXPgc5MLnIBc+B7nwOciFz0EtfA5q4XNQC5+DWvgc1MLnoBY+B7XwOaiFz0EtfA5q4XPQC5+DXvgc9MLnoBc+B73wOeiFz0EvfA564XPQC5+DXvgczMLnYBY+B7PwOZiFz8EsfA5m4XMwC5+DWfgczMLnYH7758CPY2GNLKzRhTW2sMYX1sTCmlxYUwtremHNwudAFj4HsvA5kIXPgSx8DmThcyALn4P3HSCt32SjTnlYUr99Sf/2JfObl7xPx/94yfkv8ssflIUPqSx8SGXhQyoLH1JZ+JDKwodUFj6ksvAhFcmFNbWwZuFzIAufA134HOjC50AXPge68DnQhc+BLnwOdOFzoAufA134HOjC58AWPge28DlYEL1lQfSWBdFbFkRvWRC9ZUH0lgXRWxZEb1kQvWVB9JYF0VsWRG9ZEL1lQfSWBdFbFkRvWRC9ZUH0lgXRWxZEb1kQvWVB9JYF0VsWRG9ZEL1lQfSWBdFbFkRvWRC9ZUH0lgXRWxZEb1kQvWVB9JYF0VsWRG9ZEL1lQfSWBdFbFkRvWRC9ZUH0lgXRWxZEb1kQvWVB9JYF0VsWRG9ZEL1lQfSWBdFbFkRvWRC9ZUH0lgXRWxZEb1kQvWVB9JYF0VsWRG9ZEL1lQfSWBdFbFkRvWRC9ZUH0lgXRWxZEb10QvXVB9NYF0VsXRG9dEL11QfTWBdFbF0RvXdATdUFP1AU9URf0RF3QE3VBT9QFPVEX9ERd0BN1QU/UBT1RF/REXdATdUFP1AU9URf0RF3QE3VBT9QFPVEX9ERd0BN1QU/UBT1RF/REXdATdUFP1AU9URf0RF3QE3VBT9QFPVEX9ERd0BN1QU/UBT1RF/REXdATdUFP1AU9URf0RF3QE3VBT9QFPVEX9ERd0BN1QU/UBT1RF/REXdATdUFP1AU9URf0RF3QE3VBT9QFPVEX9ERd0BN1QU/UBT1RF/REXdATdUFP1AU9URf0RF3QE3VBT9QFPVEX9ERd0BN1QU/UBT1RF/REXdATfzCQ8iMe5wcTIz9eYr99if/2JfHblpz/or/8QVtolr8cZ1+Osz+v+XKcfTnOvhxnf17z5Tj7cpx9Oc7+vObLcfblOPtynP15zZfj7Mtx9uU4+/OaL8fZl+PsZRxnF2sWPgcLP777wo/vvvDjuy/8+O4LP777wo/vvvDjuy/8+O4LP777wo/vvvDjuy/8+O4LP777gp7oC3qiL+iJvqAn+oKe6At6oi/oib6gJ/qCnugLeqIv6Im+oCf6gp7oC3qiL+iJvqAn+oKe6At6oi/oib6gJ/qCnugLeqIv6Im+oCf6gp7oC3qiL+iJvqAn+oKe6At6oi/oib6gJ/qCnugLeqIv6Im+oCf6gp7oC3qiL+iJvqAn+oKe6At6oi/oib6gJ/qCnugLeqIv6Im+oCf6gp7oC3qiL+iJvqAn+oKe6At6oi/oib6gJ/qCnugLeqIv6Im+oCf6gp7oC3qiL+iJvqAn+oKe6At6oi/oib6gJ/qCnhgLemIs6ImxoCfGgp4YC3piLOiJsaAnxoKeGAt6YizoibGgJ8aCnhgLemIs6ImxoCfGgp4YC3piLOiJsaAnxoKeGAt6YizoibGgJ8aCnhgLemIs6ImxoCfGgp4YC3piLOiJsaAnxoKeGAt6YizoibGgJ8aCnhgLemIs6ImxoCfGgp4YC3piLOiJsaAnxoKeGAt6YizoibGgJ8aCnhgLemIs6ImxoCfGgp4YC3piLOiJsaAnxoKeGAt6YizoibGgJ8aCnhgLemIs6ImxoCfGgp4YC3piLOiJsaAnxoKeGAt6YizoibGgJ8aCnhgLemIs6ImxoCfGgp4YC3piLOiJsaAnxoKeGAt6YizoibGgJ8aCnhgLemIs6ImxoCfGgp4YC3piLOiJsaAnxoKeGAt6YizoibGgJ8aCnhgLemIs6ImxoCfGgp6YC3piLuiJuaAn5oKemAt6Yi7oibmgJ+aCnpgLemIu6Im5oCfmgp6YC3piLuiJuaAn5oKemAt6Yi7oibmgJ+aCnpgLemIu6Im5oCfmgp6YC3piLuiJuaAn5oKemAt6Yi7oibmgJ+aCnpgLemIu6Im5oCfmgp6YC3piLuiJuaAn5oKemAt6Yi7oibmgJ+aCnpgLemIu6Im5oCfmgp6YC3piLuiJuaAn5oKemAt6Yi7oibmgJ+aCnpgLemIu6Im5oCfmgp6YC3piLuiJuaAn5oKemAt6Yi7oibmgJ+aCnpgLemIu6Im5oCfmgp6YC3piLuiJuaAn5oKemAt6Yi7oibmgJ+aCnpgLemIu6Im5oCfmgp6YC3piLuiJuaAn5oKemAt6Yi7oibmgJ+aCnpgLemIu6Im5oCfmgp6YC3piLuiJuaAn5oKeWAt6Yi3oibWgJ9aCnlgLemIt6Im1oCfWgp5YC3piLeiJtaAn1oKeWAt6Yi3oibWgJ9aCnlgLemIt6Im1oCfWgp5YC3piLeiJtaAn1oKeWAt6Yi3oibWgJ9aCnlgLemIt6Illv3Ha6i9L5Lcv0d++xH77Ev9tS85/sV/+oL3/8I1K/cvK8x/tbWnGL7vZ+0/fi0XvP36vFsnKIl1ZZCuLfGVRrCzKlUW1smjlEyErnwhd+UToyidCVz4RuvKJ0JVPhK58It5/HEfXtzMfcxwPi2plUa8smoVF7z+S/9MiiYdF79+90XlbFA937/0fK87fGr8tOn/ae1w0C4ve/7niapGsLHr/mrzy2yKfflg0C4vel96vFsnKondP7qn917dFofOwyFYW+cqiWFmUl4vM/3rR+yr3+QPA90X1cJ7el7mvFunKIltZ5CuLfnD35u1jlMfDM6JkZdG75Z3f8791lefX98dF7z5hT1H/eNvJ5WFRryyahUXvi6OnNvt2y2sePrDvq6NXi3Rlka0s8pVFsbIoVxbVwqL5wd9TvH1gKx+eEe+riqegF28f2OPhrfG+rHi1KBaOxvvC4tWiWlnUK4vmty/6QZji1SJZWaQri2xlka8sipVFubJo4RPxg7DDXx/CfviU/yDt8GqRriyylUXvn9y2eFsUx8Oi998a/SaVnL/P5F8vev+b2tUiWVmkK4vev3ud831RPSzylUWxsihXFtXKol5ZNAuL3pe1zt/C3j57ow9/T3b1fjp/E/pPJ/f3D39Yzk+9fBP1XB4/3+/Tbr9xD33rQM9/roeL/8G3s+n+8SvzB3F3H79nf5B3d7XIVxbFyqJcWVS/ddH5L/7LH32fPpHDS990Xp+//ki8z59crpqVVe8zKJerZGmVLq2ypVW+tCqWVr37oZIY+3a8zn/Ov/5m8/73rstVvbRqVla9/9Xr/JN1fF/VD6tkadX7dz6PfvtFJOX46wf0+19vzj/59jvC+c/+173V+99vLlf10qpZWfX+l6nzT3Z8XzV//Zh/nwW5XKVLq2xplS+tiqVVubTqR5+NmbdVKn/9BJheWjUrq+T40Yfj+wE7l8lFy6DSb7voKdNedRjfe4Xznx9kTzmEsShlLMoYi3LGooKxqGQsqhiL6p9SVM2vipqHouZJRcn3oqT+vq+AIvozivr4O6OIMRbljEUFY1HJWFQRFqU/On3xq0YxH5fZ2jJfWxZry3JtWa0t67Vls7TMjrVlsrZs7VNia58S+8GnRC2/H5TIh2WxtizXltXasl5a5j/46zb//uywB+pIXNaW/eBOnr/mf19WDz2P/+DaQr5/pYuHH3vEZ2lZHGvLZG2Zri2ztWW+tizWluXash+cgMj6vqwemtD40afkVx+uGP34vZZzyNsvBL96Ccq884db3f/yh1tTf/2H/1TQkBWUB1tBwlaQshVkbAU5W0FBVtAPfvzJlO+i+6lO//Xj6we/yGSGfl/2+NT7wY8reb5Hvy9zfViWa8tqbVmvLZulZX2sLZO1Zbq2zNaW/eD4Zf76U/LQQf3oh6CrZbm2rNaW/eBTUsf3rr5UHpbN0rIf/Rp0tUzWlunaMltb5mvLfvApKf/Vsnh4cv3oN6GrZbW2rNeW/ehTYr9e9te9qP7oZ6GrZbK2TNeW2doyX1sWa8t+9Cn5Li2fz4R+WFZry3pt2Swtkx99SvLXy+Zhmawt07VltrbM15bF2rJcW/aDT0n/qudq1YdlvbZslpbpsbbsB5+SPn69zB6W6doyW1vma8tibVmuLau1ZT/qXvt7O9P/2arzjmBupW+dnZXlwy7znF18vu+SfydGqT/SZ/cW9fFPC/ojhfS3FpX9vah3dunnX/o7uwxilx+pvE/eRSC7POkjOW9KtfV/RuAWzsmPhO29RV2ck3jO33of3/8+Wh56n5DnX/o7uyhkF4Ps4pBdnvORbJPvu/jfyWRo9M8o6uKc5HP+1jt+9fcRDy1q+vMv/Z1dArJLQnYpyC69ortqztKyH4rDF8tkbZmuLbO1Zb62LNaW5dqyWlu29imptU9Jr31KfqQpf/zzuv5IU7bvjGD6IQ/LYm1Zri2rtWW9tmyWlv1IU75aJmvLdG2ZrS1b+5TM2qdkFj4l57/EL39YFqL3ZCF6Txai92Qhek8WovdkIXpPFqL3ZCF6Txai92Qhek8WovdkIXpPFqL3ZCF6Txai92Qhek8WovdkIXpPFkZ5yMIoD1kY5SELozxkYZSHLIzykIVRHrIwykMWRnnIwigPWRjlIQujPGRhlIcsjPKQhVEesjDKQxZGecjCKA9ZGOUhC6M8ZGGUhyyM8pCFUR6yMMpDFkZ5yMIoD1kY5SELozxkYZSHLIzykIVRHrIwykMWRnnIwigPWRjlIQujPGRhlIcsjPKQhVEesjDKQxZGecjCKA9ZGOUhC6M8ZGGUhyyM8pCFUR6yMMpDFkZ5yMIoD1kY5SELozxkYZSHLIzykIVRHrIwykMWRnnIwigPWRjlIQujPGRhlIcsjPKQhVEesjDKQxZGecjCKA9ZGOUhC6M8ZGGUhyyM8tCFUR66MMpDF0Z56MIojx+AeBdrYmFNLqyphTW9sGbhc7AwykMXRnnogp6oC3qiLuiJuqAn6oKeqAt6oi7oibqgJ+qCnqgLeqIu6Im6oCfqgp6oC3qiLuiJuqAn6oKeqAt6oi7oibqgJ+qCnqgLeqIu6Im6oCfqgp6oC3qiLuiJuqAn6oKeqAt6oi7oibqgJ+qCnqgLeqIu6Im6oCfqgp6oC3qiLuiJuqAn6oKeqAt6oi7oibqgJ+qCnqgLeqIu6Im6oCfqgp6oC3qiLuiJuqAn6oKeqAt6oi7oibqgJ+qCnqgLeqIu6Im6oCfqgp6oC3qiLuiJuqAn6oKeqAt6oi7oibqgJ+qCnqgLeqIu6Im6oCfqgp74A3rro+lyPyC3Pl5Sv31J//Yl89uW/Mf5b//vP/zrH/7hv//xn/7tXPHL//h//vkf//0P//LPf/nXf////ve3/+W//+sf/vjHP/yv//a///Vf/vGf/sf/+dd/+m9//Jd//OV/+93xy//55a/LJH5vGmcpf1IkXPX3rvULjyTf/sjI7+WQb3/ivC+/19Ff/oR+/4/4+R/xb3+kLH9fLm8j+v70H87+vff81z/9v/4fPf+b9v2/6XH83uNPRcif/nV+7ylvodnHn7ao35v1X9affz6Pt4pmzv+Yf1ttx3lFR70hVX+6hDgvIb4vkPMS8ryX5/38/wE=","file_map":{"7":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"19":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"30":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod bigint;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    /// Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    /// Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"62":{"source":"// Simple Token Contract implementation in Noir\n\nfn main(\n    // The version of the HyleOutput. This is unchecked for now.\n    version: pub u32,\n    // The initial state of the contract. This is the state before the transaction is executed.\n    initial_state_len: pub u32,\n    initial_state: pub [u8; 4],\n    // The state of the contract after the transaction is executed.\n    next_state_len: pub u32,\n    next_state: pub [u8; 4],\n    // The identity used to execute the transaction. This is the same as the one used in the\n    // BlobTransaction.\n    identity_len: pub u8,\n    identity: pub str<256>,\n    // TxHash of the BlobTransaction.\n    tx_hash: pub str<64>,\n    // ------ Blobs ------\n    // The index of the blob being executed.\n    index: pub u32,\n    // Number of blobs used by the contract\n    // If blob_number is > 1, then you need multiple occurence of parameters group \"Blob\"\n    blob_number: pub u32,\n    // --- Blob\n    // At least one blob_index must match the index parameter\n    blob_index: pub u32,\n    blob_contract_name_len: pub u8,\n    blob_contract_name: pub str<256>,\n    blob_capacity: pub u32,\n    blob_len: pub u32,\n    blob: pub [u8; 32],\n    // ---\n    // Number of blobs in the transaction. tx_blob_count >= blob_number\n    tx_blob_count: pub u32,\n    // -------------------\n    // Weither the execution was successful or not. If false, the BlobTransaction will be\n    // settled as failed.\n    success: pub bool,\n    // ------ Private inputs ------\n    password: [u8; 32],\n) {\n    let mut id: BoundedVec<u8, 256> = BoundedVec::from_parts(identity.as_bytes(), identity_len as u32);\n    id.extend_from_slice(\":\".as_bytes());\n    id.extend_from_slice(password);\n\n    println(f\"Identity: {identity}\");\n    println(f\"Password: {password}\");\n    println(f\"extended id: {id}\");\n\n    // Hash the combined input using SHA-256\n    let input_hash = sha256::sha256_var(id.storage(), identity_len as u64 + 1 + 32);\n    println(f\"Input Hash: {input_hash}\");\n\n    assert(input_hash == blob);\n\n    assert(success == true);\n    assert(version == 1);\n    assert(initial_state_len == 4);\n    assert(next_state_len == 4);\n    assert(initial_state == [0; 4]);\n    assert(next_state == [0; 4]);\n    assert(blob_capacity == 32);\n    assert(blob_len == 32);\n    assert(blob_number == 1);\n    assert(tx_blob_count >= 1);\n}\n","path":"/Users/lancelot/Programming/Hyl/xamples/check-secret-noir/contract/src/main.nr"},"65":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\n","path":"/Users/lancelot/nargo/github.com/noir-lang/sha256/v0.1.0/src/sha256.nr"}},"names":["main"],"brillig_names":["print_unconstrained","print_unconstrained","print_unconstrained","build_msg_block","attach_len_to_msg_block","print_unconstrained","directive_integer_quotient","directive_invert","directive_to_radix"]}